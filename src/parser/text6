
typedef enum syntax_access {
	SYNTAX_ACCESS_PUBLIC 				= 1 << 0,
	SYNTAX_ACCESS_PRIVATE 			= 1 << 1,
	SYNTAX_ACCESS_PROTECTED 		= 1 << 2,
	SYNTAX_ACCESS_BAN_PRIVATE 	= 1 << 3,
	SYNTAX_ACCESS_BAN_PROTECTED = 1 << 4
} syntax_access_t;

typedef enum syntax_route_type {
	SYNTAX_ROUTE_NONE 			= 1 << 0,
	SYNTAX_ROUTE_FORWARD 		= 1 << 1
} syntax_route_type_t;


static symbol_t *
syntax_in_backward(symbol_t *t1, symbol_t *t2)
{
	if (t1 == t2)
	{
		return t2;
	}
	if (t2->parent)
	{
		return syntax_in_backward(t1, t2->parent);
	}
	return NULL;
}

static symbol_t *
syntax_root_of_in_scope(program_t *program, symbol_t *base, symbol_t *t1, symbol_t *arguments, int32_t route)
{
	symbol_t *a;
	for (a = base->begin;(a != base->end);a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_CLASS))
		{
			symbol_t *ak;
			ak = syntax_extract_with(a, SYMBOL_KEY);
			if (ak)
			{
				if (syntax_comparison_id(ak, t1) == 1)
				{
					symbol_t *gs;
					gs = syntax_only_with(a, SYMBOL_GENERICS);
					if (gs)
					{
						if (arguments)
						{
							if (syntax_gsas(program, gs, arguments))
							{
								goto region_access;
							}
							continue;
						}
						else
						{
							int32_t no_match = 0;
							symbol_t *b;
							for (b = gs->begin;b != gs->end;b = b->next)
							{
								if (symbol_check_type(b, SYMBOL_GENERIC))
								{
									symbol_t *bv;
									bv = syntax_only_with(b, SYMBOL_VALUE);
									if (!bv)
									{
										no_match = 1;
										break;
									}
								}
							}
							if (no_match)
							{
								goto region_access;
							}
						}
					}
					else
					{
						if (arguments)
						{
							continue;
						}
						goto region_access;
					}
				}
				continue;
			}
			else
			{
				syntax_error(program, a, "does not include the key field");
				return NULL;
			}
			continue;
		}

		if (symbol_check_type(a, SYMBOL_GENERICS))
		{
			symbol_t *b;
			for (b = a->begin;b != a->end;b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_GENERIC))
				{
					symbol_t *bk;
					bk = syntax_extract_with(b, SYMBOL_KEY);
					if (bk)
					{
						if ((syntax_comparison_id(bk, t1) == 1) && (bk != t1) && !arguments)
						{
							return b;
						}
					}
				}
			}
			continue;
		}
		
		continue;
region_access:
		if ((route == (route & SYNTAX_ROUTE_FORWARD)))
		{
			if (!syntax_in_backward(base, a))
			{
				if (symbol_check_type(a, SYMBOL_CLASS))
				{
					node_class_t *class = a->declaration->value;
					if ((class->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
					{
						syntax_error(program, a, "private access");
						return NULL;
					}
				}
			}
		}
		return a;
	}

	if (base->parent && (route == (route & SYNTAX_ROUTE_NONE)))
	{
		return syntax_root_of_in_scope(program, base->parent, t1, arguments, route);
	}

	return NULL;
}

static symbol_t *
syntax_root_of_by_arguments(program_t *program, symbol_t *base, symbol_t *t1, symbol_t *arguments, int32_t route)
{
	if (symbol_check_type(t1, SYMBOL_ATTR))
	{
		symbol_t *left;
		left = syntax_extract_with(t1, SYMBOL_LEFT);
		if (left)
		{
			symbol_t *right;
			right = syntax_extract_with(t1, SYMBOL_RIGHT);
			if (right)
			{
				symbol_t *r1;
				r1 = syntax_root_of_by_arguments(program, base, left, NULL, route);
				if (r1)
				{
					symbol_t *r2;
					r2 = syntax_root_of_by_arguments(program, r1, right, arguments, SYNTAX_ROUTE_FORWARD);
					if (r2)
					{
						return r2;
					}
					else
					{
						syntax_error(program, right, "field not found in (%lld:%lld)",
							r1->declaration->position.line, r1->declaration->position.column);
						return NULL;
					}
				}
				else
				{
					syntax_error(program, left, "field not found");
					return NULL;
				}
			}
			else
			{
				syntax_error(program, t1, "attribute does not include the right field");
				return NULL;
			}
		}
		else
		{
			syntax_error(program, t1, "attribute does not include the left field");
			return NULL;
		}
	}
	else 
	if (symbol_check_type(t1, SYMBOL_COMPOSITE))
	{
		symbol_t *key;
		key = syntax_extract_with(t1, SYMBOL_KEY);
		if (key)
		{
			symbol_t *arguments1;
			arguments1 = syntax_extract_with(t1, SYMBOL_ARGUMENTS);
			if (arguments1)
			{
				symbol_t *r1;
				r1 = syntax_root_of_by_arguments(program, base, key, arguments1, route);
				if (r1)
				{
					return r1;
				}
				else
				{
					syntax_error(program, key, "field not found");
					return NULL;
				}
			}
			else
			{
				syntax_error(program, t1, "attribute does not include the arguments field");
				return NULL;
			}
		}
		else
		{
			syntax_error(program, t1, "attribute does not include the key field");
			return NULL;
		}
	}
	else
	if (symbol_check_type(t1, SYMBOL_ID))
	{
		symbol_t *r;
		r = syntax_root_of_in_scope(program, base, t1, arguments, route);
		if (r)
		{
			return r;
		}
		else
		{
			return NULL;
		}
	}
	else
	{
		syntax_error(program, t1, "the reference is not a routable");
		return NULL;
	}
}

static symbol_t *
syntax_root_of(program_t *program, symbol_t *t1)
{
	return syntax_root_of_by_arguments(program, t1->parent, t1, NULL, SYNTAX_ROUTE_NONE);
}













static int32_t
syntax_tt(program_t *program, symbol_t *t1, symbol_t *t2)
{
	if (symbol_check_type(t1, SYMBOL_AND))
	{
		int32_t r = 1;

		symbol_t *left;
		left = syntax_extract_with(t1, SYMBOL_LEFT);
		if (left)
		{
			int32_t rl;
			rl = syntax_tt(program, left, t2);
			if (rl == -1)
			{
				return -1;
			}
			else
			{
				r &= rl;
			}
		}

		symbol_t *right;
		right = syntax_extract_with(t1, SYMBOL_RIGHT);
		if (right)
		{
			int32_t rr;
			rr = syntax_tt(program, right, t2);
			if (rr == -1)
			{
				return -1;
			}
			else
			{
				r &= rr;
			}
		}

		return r;
	}
	else
	if (symbol_check_type(t1, SYMBOL_OR))
	{
		int32_t r = 1;
		
		symbol_t *left;
		left = syntax_extract_with(t1, SYMBOL_LEFT);
		if (left)
		{
			int32_t rl;
			rl = syntax_tt(program, left, t2);
			if (rl == -1)
			{
				return -1;
			}
			else
			{
				r |= rr;
			}
		}

		symbol_t *right;
		right = syntax_extract_with(t1, SYMBOL_RIGHT);
		if (right)
		{
			int32_t rr;
			rr = syntax_tt(program, right, t2);
			if (rr == -1)
			{
				return -1;
			}
			else
			{
				r |= rr;
			}
		}

		return r;
	}
	else
	{
		if (symbol_check_type(t2, SYMBOL_AND))
		{
			int32_t r1 = 0;

			symbol_t *left;
			left = syntax_extract_with(t2, SYMBOL_LEFT);
			if (left)
			{
				int32_t rl;
				rl = syntax_tt(program, t1, left);
				if (rl == -1)
				{
					return -1;
				}
				else
				{
					r1 = rl;
				}
			}

			int32_t r2 = 0;

			symbol_t *right;
			right = syntax_extract_with(t2, SYMBOL_RIGHT);
			if (right)
			{
				int32_t rr;
				rr = syntax_tt(program, t1, right);
				if (rr == -1)
				{
					return -1;
				}
				else
				{
					r2 = rr;
				}
			}

			return r1 & r2;
		}
		else
		if (symbol_check_type(t2, SYMBOL_OR))
		{
			int32_t r = 1;

			symbol_t *left;
			left = syntax_extract_with(t2, SYMBOL_LEFT);
			if (left)
			{
				int32_t rl;
				rl = syntax_tt(program, t1, left);
				if (rl == -1)
				{
					return -1;
				}
				else
				{
					r |= rl;
				}
			}

			symbol_t *right;
			right = syntax_extract_with(t2, SYMBOL_RIGHT);
			if (right)
			{
				int32_t rr;
				rr = syntax_tt(program, t1, right);
				if (rr == -1)
				{
					return -1;
				}
				else
				{
					r |= rr;
				}
			}

			return r;
		}
		else
		{
			symbol_t *tt1;
			tt1 = syntax_root_of(program, t1);
			if (tt1)
			{
				symbol_t *tt2;
				tt2 = syntax_root_of(program, t2);
				if (tt2)
				{
					return tt1 == tt2 ? 1 : 0;
				}
				else
				{
					syntax_error(program, t2, "reference not found");
					return -1;
				}
			}
			else
			{
				syntax_error(program, t1, "reference not found");
				return -1;
			}
		}
	}
	return 1;
}

static int32_t
syntax_gg(program_t *program, symbol_t *g1, symbol_t *g2)
{
	symbol_t *gt1;
	gt1 = syntax_extract_with(g1, SYMBOL_TYPE);
	if (gt1)
	{
		symbol_t *gt2;
		gt2 = syntax_extract_with(g2, SYMBOL_TYPE);
		if (gt2)
		{
			return syntax_tt(program, gt1, gt2);
		}
		else
		{
			return 1;
		}
	}
	return 1;
}

static int32_t
syntax_gsgs(program_t *program, symbol_t *gs1, symbol_t *gs2)
{
	uint64_t gs1_cnt = 0;
	uint64_t gs2_cnt = 0;

	symbol_t *a;
	for (a = gs1->begin;a != gs1->end;a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_GENERIC))
		{
			gs1_cnt += 1;
			gs2_cnt = 0;

			symbol_t *b;
			for (b = gs2->begin;b != gs2->end;b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_GENERIC))
				{
					gs2_cnt += 1;
					if (gs2_cnt < gs1_cnt)
					{
						continue;
					}
					int32_t result;
					result = syntax_gg(program, a, b);
					if (result == -1)
					{
						return -1;
					}
					else 
					if (result == 0)
					{
						return 0;
					}
					break;
				}
			}
			
			if (gs2_cnt < gs1_cnt)
			{
				symbol_t *value;
				value = syntax_only_with(a, SYMBOL_VALUE);
				if (!value)
				{
					return 0;
				}
			}
		}
	}

	gs2_cnt = 0;
	symbol_t *b;
	for (b = gs2->begin;b != gs2->end;b = b->next)
	{
		if (symbol_check_type(b, SYMBOL_GENERIC))
		{
			gs2_cnt += 1;
			if (gs2_cnt > gs1_cnt)
			{
				symbol_t *value;
				value = syntax_only_with(b, SYMBOL_VALUE);
				if (!value)
				{
					return 0;
				}
			}
		}
	}

	return 1;
}

static int32_t
syntax_pp(program_t *program, symbol_t *p1, symbol_t *p2)
{
	symbol_t *pt1;
	pt1 = syntax_extract_with(p1, SYMBOL_TYPE);
	if (pt1)
	{
		symbol_t *pt2;
		pt2 = syntax_extract_with(p2, SYMBOL_TYPE);
		if (pt2)
		{
			return syntax_tt(program, pt1, pt2);
		}
		else
		{
			return 1;
		}
	}

	return 1;
}

static int32_t
syntax_psps(program_t *program, symbol_t *ps1, symbol_t *ps2)
{
	uint64_t ps1_cnt = 0;
	uint64_t ps2_cnt = 0;

	symbol_t *a;
	for (a = ps1->begin;a != ps1->end;a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_PARAMETER))
		{
			ps1_cnt += 1;
			ps2_cnt = 0;

			symbol_t *b;
			for (b = ps2->begin;b != ps2->end;b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_PARAMETER))
				{
					ps2_cnt += 1;
					if (ps2_cnt < ps1_cnt)
					{
						continue;
					}
					int32_t result;
					result = syntax_pp(program, a, b);
					if (result == -1)
					{
						return -1;
					}
					else 
					if (result == 0)
					{
						return 0;
					}
					break;
				}
			}
			
			if (ps2_cnt < ps1_cnt)
			{
				symbol_t *value;
				value = syntax_only_with(a, SYMBOL_VALUE);
				if (!value)
				{
					return 0;
				}
			}
		}
	}

	ps2_cnt = 0;
	symbol_t *b;
	for (b = ps2->begin;b != ps2->end;b = b->next)
	{
		if (symbol_check_type(b, SYMBOL_GENERIC))
		{
			ps2_cnt += 1;
			if (ps2_cnt > ps1_cnt)
			{
				symbol_t *value;
				value = syntax_only_with(b, SYMBOL_VALUE);
				if (!value)
				{
					return 0;
				}
			}
		}
	}

	return 1;
}

static int32_t
syntax_aa(program_t *program, symbol_t *a1, symbol_t *a2)
{
	symbol_t *ak1;
	ak1 = syntax_extract_with(a1, SYMBOL_KEY);
	if (ak1)
	{
		symbol_t *ak2;
		ak2 = syntax_extract_with(a2, SYMBOL_KEY);
		if (ak2)
		{
			return syntax_tt(program, ak1, ak2);
		}
		else
		{
			syntax_error(program, a2, "argument without key");
			return -1;
		}
	}
	else
	{
		syntax_error(program, a1, "argument without key");
		return -1;
	}
	return 1;
}

static int32_t
syntax_asas(program_t *program, symbol_t *as1, symbol_t *as2)
{
	uint64_t as1_cnt = 0;
	uint64_t as2_cnt = 0;

	symbol_t *a;
	for (a = as1->begin;a != as1->end;a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_ARGUMENT))
		{
			as1_cnt += 1;
			as2_cnt = 0;

			symbol_t *b;
			for (b = as2->begin;b != as2->end;b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_ARGUMENT))
				{
					as2_cnt += 1;
					if (as2_cnt < as1_cnt)
					{
						continue;
					}
					int32_t result;
					result = syntax_aa(program, a, b);
					if (result == -1)
					{
						return -1;
					}
					else 
					if (result == 0)
					{
						return 0;
					}
					break;
				}
			}

			if (as2_cnt < as1_cnt)
			{
				symbol_t *value;
				value = syntax_only_with(a, SYMBOL_VALUE);
				if (!value)
				{
					return 0;
				}
			}

		}
	}

	as2_cnt = 0;
	symbol_t *b;
	for (b = as2->begin;b != as2->end;b = b->next)
	{
		if (symbol_check_type(b, SYMBOL_ARGUMENT))
		{
			as2_cnt += 1;
			if (as2_cnt > as1_cnt)
			{
				symbol_t *value;
				value = syntax_only_with(b, SYMBOL_VALUE);
				if (!value)
				{
					return 0;
				}
			}
		}
	}

	return 1;
}

static int32_t
syntax_ga(program_t *program, symbol_t *g1, symbol_t *a1)
{
	symbol_t *gk1;
	gk1 = syntax_extract_with(g1, SYMBOL_KEY);
	if (gk1)
	{
		symbol_t *ak1;
		ak1 = syntax_extract_with(a1, SYMBOL_KEY);
		if (ak1)
		{
			if (syntax_strcmp(gk1, ak1) == 0)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			syntax_error(program, a1, "argument without key");
			return -1;
		}
	}
	else
	{
		syntax_error(program, g1, "generic without key");
		return -1;
	}
	return 1;
}

static int32_t
syntax_gsas(program_t *program, symbol_t *gs1, symbol_t *as1)
{
	uint64_t gs1_cnt = 0;
	uint64_t as1_cnt = 0;

	symbol_t *a;
	for (a = gs1->begin;a != gs1->end;a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_GENERIC))
		{
			gs1_cnt += 1;
			as1_cnt = 0;

			symbol_t *b;
			for (b = as1->begin;b != as1->end;b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_ARGUMENT))
				{
					as1_cnt += 1;
					if (as1_cnt < gs1_cnt)
					{
						continue;
					}
					int32_t result;
					result = syntax_ga(program, a, b);
					if (result == 0)
					{
						return 0;
					}
					else 
					if (result == -1)
					{
						return -1;
					}
					break;
				}
			}
			
			if (as1_cnt < gs1_cnt)
			{
				symbol_t *value;
				value = syntax_only_with(a, SYMBOL_VALUE);
				if (!value)
				{
					return 0;
				}
			}
		}
	}

	as1_cnt = 0;
	symbol_t *b;
	for (b = as1->begin;b != as1->end;b = b->next)
	{
		if (symbol_check_type(b, SYMBOL_ARGUMENT))
		{
			as1_cnt += 1;
			if (as1_cnt > gs1_cnt)
			{
				return 0;
			}
		}
	}

	return 1;
}



