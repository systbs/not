
static int32_t
syntax_select(program_t *program, node_t *root, char *name, list_t *response)
{
    if (root->kind == NODE_KIND_BODY)
    {
        node_block_t *block1 = (node_block_t *)root->value;

        ilist_t *a1;
        for (a1 = block1->list->begin;a1 != block1->list->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            if (item1->kind == NODE_KIND_IF)
            {
                node_if_t *if1 = (node_if_t *)item1->value;
                if (if1->key != NULL)
                {
                    if (syntax_idstrcmp(if1->key, name) == 1)
                    {
                        ilist_t *r1 = list_rpush(response, item1);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_FOR)
            {
                node_for_t *for1 = (node_for_t *)item1->value;
                if (for1->key != NULL)
                {
                    if (syntax_idstrcmp(for1->key, name) == 1)
                    {
                        ilist_t *r1 = list_rpush(response, item1);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_FORIN)
            {
                node_forin_t *forin1 = (node_forin_t *)item1->value;
                if (forin1->key != NULL)
                {
                    if (syntax_idstrcmp(forin1->key, name) == 1)
                    {
                        ilist_t *r1 = list_rpush(response, item1);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_VAR)
            {
                node_var_t *var1 = (node_var_t *)item1->value;
                if (var1->key->kind == NODE_KIND_ID)
                {
                    if (syntax_idstrcmp(var1->key, name) == 1)
                    {
                        ilist_t *r1 = list_rpush(response, item1);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                    }
                }
                else
                {
                    node_t *node2 = (node_t *)var1->key;
                    node_block_t *block2 = (node_block_t *)node2->value;
                    ilist_t *a2;
                    for (a2 = block2->list->begin;a2 != block2->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_PROPERTY)
                        {
                            node_property_t *property2 = (node_property_t *)item2->value;
                            if (property2->type == NULL)
                            {
                                if (syntax_idstrcmp(property2->key, name) == 1)
                                {
                                    ilist_t *r1 = list_rpush(response, item2);
                                    if (r1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                }
                            }
                            else
                            {
                                if (syntax_idstrcmp(property2->key, name) == 1)
                                {
                                    ilist_t *r1 = list_rpush(response, item2);
                                    if (r1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    else
    if (root->kind == NODE_KIND_FUN)
    {
        node_fun_t *func2 = (node_fun_t *)root->value;
        if (func2->generics != NULL)
        {
            node_t *node2 = func2->generics;
            node_block_t *block2 = (node_block_t *)node2->value;

            ilist_t *a2;
            for (a2 = block2->list->begin;a2 != block2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;

                if (item2->kind == NODE_KIND_GENERIC)
                {
                    node_generic_t *generic3 = (node_generic_t *)item2->value;
                    if (syntax_idstrcmp(generic3->key, name) == 1)
                    {
                        ilist_t *r1 = list_rpush(response, item2);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                    }
                }
            }
        }

        if (func2->parameters != NULL)
        {
            node_t *node3 = func2->parameters;
            node_block_t *block3 = (node_block_t *)node3->value;

            ilist_t *a3;
            for (a3 = block3->list->begin;a3 != block3->list->end;a3 = a3->next)
            {
                node_t *item3 = (node_t *)a3->value;

                if (item3->kind == NODE_KIND_PARAMETER)
                {
                    node_parameter_t *parameter3 = (node_parameter_t *)item3->value;
                    if (syntax_idstrcmp(parameter3->key, name) == 1)
                    {
                        ilist_t *r1 = list_rpush(response, item3);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                    }
                }
            }
        }
    }
    else
    if (root->kind == NODE_KIND_CLASS)
    {
        node_class_t *class1 = (node_class_t *)root->value;
        node_t *node1 = class1->block;
        node_block_t *block1 = (node_block_t *)node1->value;
        ilist_t *a1;
        for (a1 = block1->list->begin;a1 != block1->list->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            if (item1->kind == NODE_KIND_CLASS)
            {
                node_class_t *class1p = (node_class_t *)item1->value;
                if (syntax_idstrcmp(class1p->key, name) == 1)
                {
                    ilist_t *r1 = list_rpush(response, item1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_ENUM)
            {
                node_enum_t *enum1 = (node_enum_t *)item1->value;
                if (syntax_idstrcmp(enum1->key, name) == 1)
                {
                    ilist_t *r1 = list_rpush(response, item1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_FUN)
            {
                node_fun_t *func1 = (node_fun_t *)item1->value;
                if (syntax_idstrcmp(func1->key, name) == 1)
                {
                    ilist_t *r1 = list_rpush(response, item1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_PROPERTY)
            {
                node_property_t *property1 = (node_property_t *)item1->value;
                if (syntax_idstrcmp(property1->key, name) == 1)
                {
                    ilist_t *r1 = list_rpush(response, item1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
        }

        if (class1->generics != NULL)
        {
            node_t *node2 = class1->generics;
            node_block_t *block2 = (node_block_t *)node2->value;

            ilist_t *a2;
            for (a2 = block2->list->begin;a2 != block2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;

                if (item2->kind == NODE_KIND_GENERIC)
                {
                    node_generic_t *generic3 = (node_generic_t *)item2->value;
                    if (syntax_idstrcmp(generic3->key, name) == 1)
                    {
                        ilist_t *r1 = list_rpush(response, item2);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                    }
                }
            }
        }

        if (class1->heritages != NULL)
        {
            node_t *node2 = class1->heritages;
            node_block_t *block2 = (node_block_t *)node2->value;

            ilist_t *a2;
            for (a2 = block2->list->begin;a2 != block2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;

                if (item2->kind == NODE_KIND_HERITAGE)
                {
                    node_heritage_t *heritage3 = (node_heritage_t *)item2->value;
                    if (syntax_idstrcmp(heritage3->key, name) == 1)
                    {
                        ilist_t *r1 = list_rpush(response, item2);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                    }
                }
            }
        }

        if (class1->heritages != NULL)
        {
            node_t *node2 = class1->heritages;
            node_block_t *block2 = (node_block_t *)node2->value;

            list_t *repository = list_create();
            if (repository == NULL)
            {
                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                return -1;
            }
            list_t *repository_list = list_create();
            if (repository_list == NULL)
            {
                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                return -1;
            }

            int32_t start_new = 0;

            ilist_t *a2 = block2->list->begin;
            while (a2 != NULL)
            {
                node_t *item2 = (node_t *)a2->value;

                if (item2->kind == NODE_KIND_HERITAGE)
                {
                    node_heritage_t *heritage3 = (node_heritage_t *)item2->value;
                    
                    list_t *response2 = list_create();
                    if (response2 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                    int32_t r1 = syntax_postfix(program, heritage3->type, response2);
                    if (r1 == -1)
                    {
                        return -1;
                    }
                    else
                    if (r1 == 0)
                    {
                        syntax_error(program, heritage3->key, "reference not found");
                        return -1;
                    }
                    else
                    if (r1 == 1)
                    {
                        ilist_t *a3;
                        for (a3 = response2->begin;a3 != response2->end;a3 = a3->next)
                        {
                            node_t *item3 = (node_t *)a3->value;
                            if (item3->kind == NODE_KIND_CLASS)
                            {
                                node_class_t *class4 = (node_class_t *)item3->value;
                                node_t *node4 = class4->block;
                                node_block_t *block4 = (node_block_t *)node4->value;
                                ilist_t *a4;
                                for (a4 = block4->list->begin;a4 != block4->list->end;a4 = a4->next)
                                {
                                    node_t *item4 = (node_t *)a4->value;
                                    if (item4->kind == NODE_KIND_CLASS)
                                    {
                                        node_class_t *class1p = (node_class_t *)item4->value;
                                        if (syntax_idstrcmp(class1p->key, name) == 1)
                                        {
                                            ilist_t *r1 = list_rpush(response, item4);
                                            if (r1 == NULL)
                                            {
                                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                return -1;
                                            }
                                        }
                                    }
                                    else
                                    if (item4->kind == NODE_KIND_ENUM)
                                    {
                                        node_enum_t *enum1 = (node_enum_t *)item4->value;
                                        if (syntax_idstrcmp(enum1->key, name) == 1)
                                        {
                                            ilist_t *r1 = list_rpush(response, item4);
                                            if (r1 == NULL)
                                            {
                                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                return -1;
                                            }
                                        }
                                    }
                                    else
                                    if (item4->kind == NODE_KIND_FUN)
                                    {
                                        node_fun_t *func1 = (node_fun_t *)item4->value;
                                        if (syntax_idstrcmp(func1->key, name) == 1)
                                        {
                                            ilist_t *r1 = list_rpush(response, item4);
                                            if (r1 == NULL)
                                            {
                                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                return -1;
                                            }
                                        }
                                    }
                                    else
                                    if (item4->kind == NODE_KIND_PROPERTY)
                                    {
                                        node_property_t *property1 = (node_property_t *)item4->value;
                                        if (syntax_idstrcmp(property1->key, name) == 1)
                                        {
                                            ilist_t *r1 = list_rpush(response, item4);
                                            if (r1 == NULL)
                                            {
                                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                return -1;
                                            }
                                        }
                                    }
                                }

                                ilist_t *r5 = list_rpush(repository_list, a2);
                                if (r5 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }

                                ilist_t *r6 = list_rpush(repository, node2);
                                if (r6 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }

                                node2 = class4->heritages;
                                block2 = (node_block_t *)node2->value;
                                a2 = block2->list->begin;
                                start_new = 1;
                                break;
                            }
                        }
                    }
                
                }

                if (a2 == block2->list->end)
                {
                    ilist_t *r5 = list_rpop(repository_list);
                    if (r5 != NULL)
                    {
                        a2 = (ilist_t *)r5->value;
                    }
                    ilist_t *r6 = list_rpop(repository);
                    if (r6 != NULL)
                    {
                        node2 = (node_t *)r6->value;
                        block2 = (node_block_t *)node2->value;
                        continue;
                    }
                    break;
                }
                else
                {
                    if (start_new != 1)
                    {
                        a2 = a2->next;
                    }
                    start_new = 0;
                }
            }

            list_destroy(repository_list);
            list_destroy(repository);
        }
    }
    else
    if (root->kind == NODE_KIND_MODULE)
    {
        node_class_t *class1 = (node_class_t *)root->value;
        node_t *node1 = class1->block;
        node_block_t *block1 = (node_block_t *)node1->value;
        ilist_t *a1;
        for (a1 = block1->list->begin;a1 != block1->list->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            if (item1->kind == NODE_KIND_CLASS)
            {
                node_class_t *class1p = (node_class_t *)item1->value;
                if (syntax_idstrcmp(class1p->key, name) == 1)
                {
                    ilist_t *r1 = list_rpush(response, item1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_ENUM)
            {
                node_enum_t *enum1 = (node_enum_t *)item1->value;
                if (syntax_idstrcmp(enum1->key, name) == 1)
                {
                    ilist_t *r1 = list_rpush(response, item1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
        }
    }

    if (root->parent != NULL)
    {
        return syntax_select(program, root->parent, name, response);
    }

    return 0;
}

static int32_t
syntax_id(program_t *program, node_t *node, list_t *response)
{
    node_basic_t *nb1 = (node_basic_t *)node->value;
    return syntax_select(program, node->parent, nb1->value, response);
}

static int32_t
syntax_number(program_t *program, node_t *node, list_t *response)
{
    return syntax_select(program, node->parent, "Int", response);
}

static int32_t
syntax_char(program_t *program, node_t *node, list_t *response)
{
    return syntax_select(program, node->parent, "Char", response);
}

static int32_t
syntax_string(program_t *program, node_t *node, list_t *response)
{
    return syntax_select(program, node->parent, "String", response);
}

static int32_t
syntax_infinity(program_t *program, node_t *node, list_t *response)
{
    return syntax_select(program, node->parent, "Int", response);
}

static int32_t
syntax_array(program_t *program, node_t *node, list_t *response)
{
    ilist_t *r1 = list_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }
    return 1;
}

static int32_t
syntax_object(program_t *program, node_t *node, list_t *response)
{
    ilist_t *r1 = list_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }
    return 1;
}

static int32_t
syntax_null(program_t *program, node_t *node, list_t *response)
{
    ilist_t *r1 = list_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }
    return 1;
}

static int32_t
syntax_primary(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_ID)
    {
        return syntax_id(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_NUMBER)
    {
        return syntax_number(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_CHAR)
    {
        return syntax_char(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_STRING)
    {
        return syntax_string(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_NULL)
    {
        return syntax_null(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_INFINITY)
    {
        return syntax_infinity(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_ARRAY)
    {
        return syntax_array(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_OBJECT)
    {
        return syntax_object(program, node, response);
    }
    return 1;
}

static int32_t
syntax_pseudonym(program_t *program, node_t *node, list_t *response)
{
    node_carrier_t *carrier = (node_carrier_t *)node->value;
    
    list_t *response1 = list_create();
    if (response1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }

    int32_t r1 = syntax_postfix(program, carrier->base, response1);
    if (r1 == -1)
    {
        return -1;
    }
    else
    if (r1 == 0)
    {
        syntax_error(program, node, "reference not found");
        return -1;
    }
    else
    if (r1 == 1)
    {
        ilist_t *a1;
        for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            if (item1->kind == NODE_KIND_CLASS)
            {
                node_class_t *class1 = (node_class_t *)item1->value;
                node_t *ngs1 = class1->generics;
                node_t *nas2 = carrier->data;
                int32_t r1 = syntax_eqaul_gscs(program, ngs1, nas2);
                if (r1 == -1)
                {
                    return -1;
                }
                else
                if (r1 == 1)
                {
                    node_t *clone1 = node_clone(item1);
                    if (clone1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                    clone1->concepts = carrier->data;
                    ilist_t *il1 = list_rpush(response, clone1);
                    if (il1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                    return 1;
                }
            }
            else
            if (item1->kind == NODE_KIND_FUN)
            {
                node_fun_t *func1 = (node_fun_t *)item1;
                node_t *ngs1 = func1->generics;
                node_t *nas2 = carrier->data;
                int32_t r1 = syntax_eqaul_gscs(program, ngs1, nas2);
                if (r1 == -1)
                {
                    return -1;
                }
                else
                if (r1 == 1)
                {
                    node_t *clone1 = node_clone(item1);
                    if (clone1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                    clone1->concepts = carrier->data;
                    ilist_t *il1 = list_rpush(response, clone1);
                    if (il1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                    return 1;
                }
            }
            else
            {
                syntax_error(program, node, "generic type used for (%lld:%lld)",
                    item1->position.line, item1->position.column);
                return -1;
            }
        }
    }

    list_destroy(response1);
    return 0;
}

static int32_t
syntax_call(program_t *program, node_t *node, list_t *response)
{
    node_carrier_t *carrier = (node_carrier_t *)node->value;
    
    list_t *response1 = list_create();
    if (response1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }

    int32_t r1 = syntax_postfix(program, carrier->base, response1);
    if (r1 == -1)
    {
        return -1;
    }
    else
    if (r1 == 0)
    {
        syntax_error(program, node, "reference not found");
        return -1;
    }
    else
    if (r1 == 1)
    {
        ilist_t *a1;
        for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            if (item1->kind == NODE_KIND_CLASS)
            {
                node_class_t *class1 = (node_class_t *)item1->value;
                node_t *node1 = class1->block;
                node_block_t *block1 = (node_block_t *)node1->value;
                ilist_t *b1;
                for (b1 = block1->list->begin;b1 != block1->list->end;b1 = b1->next)
                {
                    node_t *item2 = (node_t *)b1->value;
                    if (item2->kind == NODE_KIND_FUN)
                    {
                        node_fun_t *func1 = (node_fun_t *)item2->value;
                        if (syntax_idstrcmp(func1->key, "constructor") == 1)
                        {
                            node_t *nps1 = func1->parameters;
                            node_t *nds2 = carrier->data;
                            int32_t r2 = syntax_eqaul_psas(program, nps1, nds2);
                            if (r2 == -1)
                            {
                                return -1;
                            }
                            else
                            if (r2 == 1)
                            {
                                node_t *clone1 = node_clone(item1);
                                if (clone1 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                clone1->arguments = carrier->data;
                                ilist_t *il1 = list_rpush(response, clone1);
                                if (il1 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                list_destroy(response1);
                                return 1;
                            }
                        }
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_FUN)
            {
                node_fun_t *func1 = (node_fun_t *)item1->value;
                node_t *nps1 = func1->parameters;
                node_t *nds2 = carrier->data;
                int32_t r1 = syntax_eqaul_psas(program, nps1, nds2);
                if (r1 == -1)
                {
                    return -1;
                }
                else
                if (r1 == 1)
                {
                    ilist_t *il1 = list_rpush(response, item1);
                    if (il1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                    list_destroy(response1);
                    return 1;
                }
            }
            else
            if (item1->kind == NODE_KIND_PROPERTY)
            {
                if (item1->referto == NULL)
                {
                    syntax_error(program, item1, "not initialized");
                    return -1;
                }
                node_t *referto = item1->referto;
                if (referto->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)referto->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *b1;
                    for (b1 = block1->list->begin;b1 != block1->list->end;b1 = b1->next)
                    {
                        node_t *item2 = (node_t *)b1->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "constructor") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nds2 = carrier->data;
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nds2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, referto);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                if (referto->kind == NODE_KIND_FUN)
                {
                    node_fun_t *func1 = (node_fun_t *)referto->value;
                    node_t *nps1 = func1->parameters;
                    node_t *nds2 = carrier->data;
                    int32_t r1 = syntax_eqaul_psas(program, nps1, nds2);
                    if (r1 == -1)
                    {
                        return -1;
                    }
                    else
                    if (r1 == 1)
                    {
                        ilist_t *il1 = list_rpush(response, referto);
                        if (il1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                        list_destroy(response1);
                        return 1;
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_PARAMETER)
            {
                if (item1->referto == NULL)
                {
                    syntax_error(program, item1, "not initialized");
                    return -1;
                }
                node_t *referto = item1->referto;
                if (referto->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)referto->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *b1;
                    for (b1 = block1->list->begin;b1 != block1->list->end;b1 = b1->next)
                    {
                        node_t *item2 = (node_t *)b1->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "constructor") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nds2 = carrier->data;
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nds2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, referto);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                if (referto->kind == NODE_KIND_FUN)
                {
                    node_fun_t *func1 = (node_fun_t *)referto->value;
                    node_t *nps1 = func1->parameters;
                    node_t *nds2 = carrier->data;
                    int32_t r1 = syntax_eqaul_psas(program, nps1, nds2);
                    if (r1 == -1)
                    {
                        return -1;
                    }
                    else
                    if (r1 == 1)
                    {
                        ilist_t *il1 = list_rpush(response, referto);
                        if (il1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                        list_destroy(response1);
                        return 1;
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_VAR)
            {
                if (item1->referto == NULL)
                {
                    syntax_error(program, item1, "not initialized");
                    return -1;
                }
                node_t *referto = item1->referto;
                if (referto->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)referto->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *b1;
                    for (b1 = block1->list->begin;b1 != block1->list->end;b1 = b1->next)
                    {
                        node_t *item2 = (node_t *)b1->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "constructor") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nds2 = carrier->data;
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nds2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, referto);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                if (referto->kind == NODE_KIND_FUN)
                {
                    node_fun_t *func1 = (node_fun_t *)referto->value;
                    node_t *nps1 = func1->parameters;
                    node_t *nds2 = carrier->data;
                    int32_t r1 = syntax_eqaul_psas(program, nps1, nds2);
                    if (r1 == -1)
                    {
                        return -1;
                    }
                    else
                    if (r1 == 1)
                    {
                        ilist_t *il1 = list_rpush(response, referto);
                        if (il1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                        list_destroy(response1);
                        return 1;
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_HERITAGE)
            {
                node_heritage_t *heritage1 = (node_heritage_t *)item1->value;
                list_t *response2 = list_create();
                if (response2 == NULL)
                {
                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                    return -1;
                }
                int32_t r2 = syntax_postfix(program, heritage1->type, response2);
                if (r2 == -1)
                {
                    return -1;
                }
                else
                if (r2 == 0)
                {
                    syntax_error(program, heritage1->type, "reference not found");
                    return -1;
                }
                else
                if (r2 == 1)
                {
                    ilist_t *a2;
                    for (a2 = response2->begin;a2 != response2->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_CLASS)
                        {
                            node_class_t *class2 = (node_class_t *)item2->value;
                            node_t *node2 = class2->block;
                            node_block_t *block2 = (node_block_t *)node2->value;

                            ilist_t *a3;
                            for (a3 = block2->list->begin;a3 != block2->list->end;a3 = a3->next)
                            {
                                node_t *item3 = (node_t *)a3->value;
                                if (item3->kind == NODE_KIND_FUN)
                                {
                                    node_fun_t *func1 = (node_fun_t *)item3->value;
                                    if (syntax_idstrcmp(func1->key, "constructor") == 1)
                                    {
                                        node_t *nps1 = func1->parameters;
                                        node_t *nds2 = carrier->data;
                                        int32_t r2 = syntax_eqaul_psas(program, nps1, nds2);
                                        if (r2 == -1)
                                        {
                                            return -1;
                                        }
                                        else
                                        if (r2 == 1)
                                        {
                                            node_t *clone1 = node_clone(item2);
                                            if (clone1 == NULL)
                                            {
                                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                return -1;
                                            }
                                            clone1->arguments = carrier->data;
                                            ilist_t *il1 = list_rpush(response, clone1);
                                            if (il1 == NULL)
                                            {
                                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                return -1;
                                            }
                                            list_destroy(response1);
                                            return 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    list_destroy(response1);

    return 0;
}

static int32_t
syntax_item(program_t *program, node_t *node, list_t *response)
{
    node_carrier_t *carrier = (node_carrier_t *)node->value;
    
    list_t *response1 = list_create();
    if (response1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }

    int32_t r1 = syntax_postfix(program, carrier->base, response1);
    if (r1 == -1)
    {
        return -1;
    }
    else
    if (r1 == 0)
    {
        syntax_error(program, node, "reference not found");
        return -1;
    }
    else
    if (r1 == 1)
    {
        ilist_t *a1;
        for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            if (item1->kind == NODE_KIND_CLASS)
            {
                if ((item1->flag & NODE_FLAG_TEMPORARY) != NODE_FLAG_TEMPORARY)
                {
                    syntax_error(program, item1, "unmade class");
                    return -1;
                }
                node_class_t *class1 = (node_class_t *)item1->value;
                node_t *node1 = class1->block;
                node_block_t *block1 = (node_block_t *)node1->value;
                ilist_t *b1;
                for (b1 = block1->list->begin;b1 != block1->list->end;b1 = b1->next)
                {
                    node_t *item2 = (node_t *)b1->value;
                    if (item2->kind == NODE_KIND_FUN)
                    {
                        node_fun_t *func1 = (node_fun_t *)item2->value;
                        if (syntax_idstrcmp(func1->key, "[]") == 1)
                        {
                            node_t *nps1 = func1->parameters;
                            node_t *nds2 = carrier->data;
                            int32_t r2 = syntax_eqaul_psas(program, nps1, nds2);
                            if (r2 == -1)
                            {
                                return -1;
                            }
                            else
                            if (r2 == 1)
                            {
                                ilist_t *il1 = list_rpush(response, func1->result);
                                if (il1 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                            }
                        }
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_ARRAY)
            {
                node_block_t *block1 = (node_block_t *)item1->value;
                ilist_t *b1;
                for (b1 = block1->list->begin;b1 != block1->list->end;b1 = b1->next)
                {
                    node_t *item2 = (node_t *)a1->value;
                    ilist_t *il1 = list_rpush(response, item2);
                    if (il1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                    break;
                }
            }
            else
            if (item1->kind == NODE_KIND_OBJECT)
            {
                node_block_t *block1 = (node_block_t *)item1->value;
                ilist_t *b1;
                for (b1 = block1->list->begin;b1 != block1->list->end;b1 = b1->next)
                {
                    node_t *item2 = (node_t *)a1->value;
                    node_pair_t *pair2 = (node_pair_t *)item2->value;
                    ilist_t *il1 = list_rpush(response, pair2->value);
                    if (il1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                    break;
                }
            }
            else
            {
                syntax_error(program, item1, "not an enumerable");
                return -1;
            }
        }
    }
    return 1;
}

static int32_t
syntax_attribute(program_t *program, node_t *node, list_t *response)
{
    node_binary_t *basic = (node_binary_t *)node->value;
    
    list_t *response1 = list_create();
    if (response1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }

    int32_t r1 = syntax_postfix(program, basic->left, response1);
    if (r1 == -1)
    {
        return -1;
    }
    else
    if (r1 == 0)
    {
        syntax_error(program, node, "reference not found");
        return -1;
    }
    else
    if (r1 == 1)
    {
        ilist_t *a1;
        for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            if (item1->kind == NODE_KIND_CLASS)
            {
                node_class_t *class2 = (node_class_t *)item1->value;
                node_t *node2 = class2->block;
                node_block_t *block2 = (node_block_t *)node2->value;
                ilist_t *a2;
                for (a2 = block2->list->begin;a2 != block2->list->end;a2 = a2->next)
                {
                    node_t *item2 = (node_t *)a2->value;
                    if (item2->kind == NODE_KIND_CLASS)
                    {
                        node_class_t *class1p = (node_class_t *)item2->value;
                        if (syntax_idcmp(basic->right, class1p->key) == 1)
                        {
                            ilist_t *r2 = list_rpush(response, item2);
                            if (r2 == NULL)
                            {
                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                return -1;
                            }
                            return 1;
                        }
                    }
                    else
                    if (item2->kind == NODE_KIND_ENUM)
                    {
                        node_enum_t *enum1 = (node_enum_t *)item2->value;
                        if (syntax_idcmp(basic->right, enum1->key) == 1)
                        {
                            ilist_t *r1 = list_rpush(response, item2);
                            if (r1 == NULL)
                            {
                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                return -1;
                            }
                            return 1;
                        }
                    }
                    else
                    if (item2->kind == NODE_KIND_FUN)
                    {
                        node_fun_t *func1 = (node_fun_t *)item2->value;
                        if (syntax_idcmp(basic->right, func1->key) == 1)
                        {
                            ilist_t *r1 = list_rpush(response, item2);
                            if (r1 == NULL)
                            {
                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                return -1;
                            }
                            return 1;
                        }
                    }
                    else
                    if (item2->kind == NODE_KIND_PROPERTY)
                    {
                        node_property_t *property1 = (node_property_t *)item2->value;
                        if (syntax_idcmp(basic->right, property1->key) == 1)
                        {
                            ilist_t *r1 = list_rpush(response, item2);
                            if (r1 == NULL)
                            {
                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                return -1;
                            }
                            return 1;
                        }
                    }
                }

                if (class2->heritages != NULL)
                {
                    node_t *node3 = class2->heritages;
                    node_block_t *block3 = (node_block_t *)node3->value;

                    list_t *repository = list_create();
                    if (repository == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                    list_t *repository_list = list_create();
                    if (repository_list == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }

                    int32_t start_new = 0;

                    ilist_t *a3 = block3->list->begin;
                    while (a3 != NULL)
                    {
                        node_t *item3 = (node_t *)a3->value;

                        if (item3->kind == NODE_KIND_HERITAGE)
                        {
                            node_heritage_t *heritage3 = (node_heritage_t *)item3->value;

                            list_t *response3 = list_create();
                            if (response3 == NULL)
                            {
                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                return -1;
                            }
                            int32_t r3 = syntax_postfix(program, heritage3->type, response3);
                            if (r3 == -1)
                            {
                                return -1;
                            }
                            else
                            if (r3 == 0)
                            {
                                syntax_error(program, heritage3->type, "reference not found");
                                return -1;
                            }
                            else
                            if (r3 == 1)
                            {
                                ilist_t *a4;
                                for (a4 = response3->begin;a4 != response3->end;a4 = a4->next)
                                {
                                    node_t *item4 = (node_t *)a4->value;
                                    if (item4->kind == NODE_KIND_CLASS)
                                    {
                                        node_class_t *class4 = (node_class_t *)item4->value;
                                        node_t *node4 = class4->block;
                                        node_block_t *block4 = (node_block_t *)node4->value;
                                        ilist_t *a4;
                                        for (a4 = block4->list->begin;a4 != block4->list->end;a4 = a4->next)
                                        {
                                            node_t *item4 = (node_t *)a4->value;
                                            if (item4->kind == NODE_KIND_CLASS)
                                            {
                                                node_class_t *class1p = (node_class_t *)item4->value;
                                                if (syntax_idcmp(basic->right, class1p->key) == 1)
                                                {
                                                    ilist_t *r1 = list_rpush(response, item4);
                                                    if (r1 == NULL)
                                                    {
                                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                        return -1;
                                                    }
                                                    return 1;
                                                }
                                            }
                                            else
                                            if (item4->kind == NODE_KIND_ENUM)
                                            {
                                                node_enum_t *enum1 = (node_enum_t *)item4->value;
                                                if (syntax_idcmp(basic->right, enum1->key) == 1)
                                                {
                                                    ilist_t *r1 = list_rpush(response, item4);
                                                    if (r1 == NULL)
                                                    {
                                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                        return -1;
                                                    }
                                                    return 1;
                                                }
                                            }
                                            else
                                            if (item4->kind == NODE_KIND_FUN)
                                            {
                                                node_fun_t *func1 = (node_fun_t *)item4->value;
                                                if (syntax_idcmp(basic->right, func1->key) == 1)
                                                {
                                                    ilist_t *r1 = list_rpush(response, item4);
                                                    if (r1 == NULL)
                                                    {
                                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                        return -1;
                                                    }
                                                    return 1;
                                                }
                                            }
                                            else
                                            if (item4->kind == NODE_KIND_PROPERTY)
                                            {
                                                node_property_t *property1 = (node_property_t *)item4->value;
                                                if (syntax_idcmp(basic->right, property1->key) == 1)
                                                {
                                                    ilist_t *r1 = list_rpush(response, item4);
                                                    if (r1 == NULL)
                                                    {
                                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                        return -1;
                                                    }
                                                    return 1;
                                                }
                                            }
                                        }

                                        ilist_t *r5 = list_rpush(repository_list, a3);
                                        if (r5 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }

                                        ilist_t *r6 = list_rpush(repository, node3);
                                        if (r6 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }

                                        node3 = class4->heritages;
                                        block3 = (node_block_t *)node3->value;
                                        a3 = block3->list->begin;
                                        start_new = 1;
                                        break;
                                    }
                                }
                            }
                        }

                        if (a3 == block2->list->end)
                        {
                            ilist_t *r5 = list_rpop(repository_list);
                            if (r5 != NULL)
                            {
                                a2 = (ilist_t *)r5->value;
                            }
                            ilist_t *r6 = list_rpop(repository);
                            if (r6 != NULL)
                            {
                                node3 = (node_t *)r6->value;
                                block3 = (node_block_t *)node3->value;
                                continue;
                            }
                            break;
                        }
                        else
                        {
                            if (start_new != 1)
                            {
                                a2 = a2->next;
                            }
                            start_new = 0;
                        }
                    }

                    list_destroy(repository_list);
                    list_destroy(repository);
                }
            }
            else
            {
                syntax_error(program, item1, "not accessable");
                return -1;
            }
        }
    }

    list_destroy(response1);

    return 0;
}

static int32_t
syntax_postfix(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_ATTRIBUTE)
    {
        return syntax_attribute(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_PSEUDONYM)
    {
        return syntax_pseudonym(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_ITEM)
    {
        return syntax_item(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_CALL)
    {
        return syntax_call(program, node, response);
    }
    else
    {
        return syntax_primary(program, node, response);
    }
    
}

static int32_t
syntax_tilde(program_t *program, node_t *node, list_t *response)
{
    node_unary_t *unary = (node_unary_t *)node->value;

    list_t *response1 = list_create();
    if (response1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }

    int32_t r1 = syntax_expression(program, unary->right, response1);
    if (r1 == -1)
    {
        return -1;
    }
    else
    if (r1 == 0)
    {
        syntax_error(program, node, "reference not found");
        return -1;
    }
    else
    if (r1 == 1)
    {
        ilist_t *a1;
        for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            ilist_t *il1 = list_rpush(response, item1);
            if (il1 == NULL)
            {
                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                return -1;
            }
            list_destroy(response1);
            return 1;
        }
    }
    list_destroy(response1);
    return 0;
}

static int32_t
syntax_pos(program_t *program, node_t *node, list_t *response)
{
    node_unary_t *unary = (node_unary_t *)node->value;

    list_t *response1 = list_create();
    if (response1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }

    int32_t r1 = syntax_expression(program, unary->right, response1);
    if (r1 == -1)
    {
        return -1;
    }
    else
    if (r1 == 0)
    {
        syntax_error(program, node, "reference not found");
        return -1;
    }
    else
    if (r1 == 1)
    {
        ilist_t *a1;
        for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            ilist_t *il1 = list_rpush(response, item1);
            if (il1 == NULL)
            {
                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                return -1;
            }
            list_destroy(response1);
            return 1;
        }
    }
    list_destroy(response1);
    return 0;
}

static int32_t
syntax_neg(program_t *program, node_t *node, list_t *response)
{
    node_unary_t *unary = (node_unary_t *)node->value;

    list_t *response1 = list_create();
    if (response1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }

    int32_t r1 = syntax_expression(program, unary->right, response1);
    if (r1 == -1)
    {
        return -1;
    }
    else
    if (r1 == 0)
    {
        syntax_error(program, node, "reference not found");
        return -1;
    }
    else
    if (r1 == 1)
    {
        ilist_t *a1;
        for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            ilist_t *il1 = list_rpush(response, item1);
            if (il1 == NULL)
            {
                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                return -1;
            }
            list_destroy(response1);
            return 1;
        }
    }
    list_destroy(response1);
    return 0;
}

static int32_t
syntax_not(program_t *program, node_t *node, list_t *response)
{
    node_unary_t *unary = (node_unary_t *)node->value;

    list_t *response1 = list_create();
    if (response1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }

    int32_t r1 = syntax_expression(program, unary->right, response1);
    if (r1 == -1)
    {
        return -1;
    }
    else
    if (r1 == 0)
    {
        syntax_error(program, node, "reference not found");
        return -1;
    }
    else
    if (r1 == 1)
    {
        ilist_t *a1;
        for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            ilist_t *il1 = list_rpush(response, item1);
            if (il1 == NULL)
            {
                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                return -1;
            }
            list_destroy(response1);
            return 1;
        }
    }
    list_destroy(response1);
    return 0;
}

static int32_t
syntax_typeof(program_t *program, node_t *node, list_t *response)
{
    node_unary_t *unary = (node_unary_t *)node->value;

    list_t *response1 = list_create();
    if (response1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }

    int32_t r1 = syntax_expression(program, unary->right, response1);
    if (r1 == -1)
    {
        return -1;
    }
    else
    if (r1 == 0)
    {
        syntax_error(program, node, "reference not found");
        return -1;
    }
    else
    if (r1 == 1)
    {
        ilist_t *a1;
        for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            ilist_t *il1 = list_rpush(response, item1);
            if (il1 == NULL)
            {
                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                return -1;
            }
            list_destroy(response1);
            return 1;
        }
    }
    list_destroy(response1);
    return 0;
}

static int32_t
syntax_sizeof(program_t *program, node_t *node, list_t *response)
{
    node_t *node2 = node_create(node->scope, node->parent, node->position);
	if (node2 == NULL)
	{
		return -1;
	}
    node2->flag = NODE_FLAG_TEMPORARY;

	node_t *node3 = node_make_number(node2, NULL);
	if (!node3)
	{
		return -1;
	}

    ilist_t *r1 = list_rpush(response, node3);
    if (r1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }
    return 1;
}

static int32_t
syntax_prefix(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_TILDE)
    {
        return syntax_tilde(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_POS)
    {
        return syntax_pos(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_NEG)
    {
        return syntax_neg(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_TYPEOF)
    {
        return syntax_typeof(program, node, response);
    }
    else
    if (node->kind == NODE_KIND_SIZEOF)
    {
        return syntax_sizeof(program, node, response);
    }
    else
    {
        return syntax_postfix(program, node, response);
    }
}

static node_t *
syntax_argument_from_node(program_t *program, node_t *arg)
{
	node_t *node = node_create(arg->scope, arg->parent, arg->position);
	if (node == NULL)
	{
		return NULL;
	}
    node->flag = NODE_FLAG_TEMPORARY;

	return node_make_argument(node, arg, NULL);
}

static node_t *
syntax_arguments_from_nodes(program_t *program, node_t *parent, uint64_t n, ...)
{
	node_t *node = node_create(parent->scope, parent, parent->position);
	if (node == NULL)
	{
		return NULL;
	}
    node->flag = NODE_FLAG_TEMPORARY;

	list_t *argements = list_create();
	if (argements == NULL)
	{
		return NULL;
	}

    va_list arg;
    va_start(arg, n);
 
    for (uint64_t i = 0; i < n; i++)
    {
        node_t *node2 = syntax_argument_from_node(program, (node_t *)va_arg(arg, node_t *));
		if (node2 == NULL)
		{
			return NULL;
		}

		if (!list_rpush(argements, node2))
		{
			return NULL;
		}
    }
    
    va_end(arg);

	return node_make_arguments(node, argements);
}

static int32_t
syntax_power(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_POW)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = 0;
        if (binary->left->kind == NODE_KIND_POW)
        {
            r1 = syntax_power(program, binary->left, response1);
        }
        else
        {
            r1 = syntax_prefix(program, binary->left, response1);
        }
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "**") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    {
        return syntax_prefix(program, node, response);
    }
}

static int32_t
syntax_multipicative(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_MUL)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_multipicative(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "*") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    if (node->kind == NODE_KIND_DIV)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_multipicative(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "/") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    if (node->kind == NODE_KIND_MOD)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_multipicative(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "%") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    if (node->kind == NODE_KIND_EPI)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_multipicative(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "\\") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    {
        return syntax_power(program, node, response);
    }
}

static int32_t
syntax_addative(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_PLUS)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_addative(program, binary->left, response1);
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "+") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    if (node->kind == NODE_KIND_MINUS)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_addative(program, binary->left, response1);
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "-") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    {
        return syntax_multipicative(program, node, response);
    }
}

static int32_t
syntax_shifting(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_SHL)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_addative(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "<<") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    if (node->kind == NODE_KIND_SHR)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_addative(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, ">>") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    {
        return syntax_addative(program, node, response);
    }
}

static int32_t
syntax_relational(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_LT)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_shifting(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "<") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    if (node->kind == NODE_KIND_LE)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_shifting(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "<=") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    if (node->kind == NODE_KIND_GT)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_shifting(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, ">") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    if (node->kind == NODE_KIND_GE)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_shifting(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, ">=") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    {
        return syntax_shifting(program, node, response);
    }
}

static int32_t
syntax_equality(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_EQ)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_relational(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "==") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    if (node->kind == NODE_KIND_NEQ)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_relational(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "!=") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    {
        return syntax_relational(program, node, response);
    }
}

static int32_t
syntax_bitwise_and(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_AND)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_equality(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "&") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    {
        return syntax_equality(program, node, response);
    }
}

static int32_t
syntax_bitwise_xor(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_XOR)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_bitwise_and(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "^") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    {
        return syntax_bitwise_and(program, node, response);
    }
}

static int32_t
syntax_bitwise_or(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_OR)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_bitwise_xor(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "|") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    {
        return syntax_bitwise_xor(program, node, response);
    }
}

static int32_t
syntax_logical_and(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_LAND)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_bitwise_or(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "&&") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    {
        return syntax_bitwise_or(program, node, response);
    }
}

static int32_t
syntax_logical_or(program_t *program, node_t *node, list_t *response)
{
    if (node->kind == NODE_KIND_LOR)
    {
        node_binary_t *binary = (node_binary_t *)node->value;

        list_t *response1 = list_create();
        if (response1 == NULL)
        {
            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
            return -1;
        }

        int32_t r1 = syntax_logical_and(program, binary->left, response1);
        
        if (r1 == -1)
        {
            return -1;
        }
        else
        if (r1 == 0)
        {
            syntax_error(program, binary->left, "reference not found");
            return -1;
        }
        else
        if (r1 == 1)
        {
            ilist_t *a1;
            for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_CLASS)
                {
                    node_class_t *class1 = (node_class_t *)item1->value;
                    node_t *node1 = class1->block;
                    node_block_t *block1 = (node_block_t *)node1->value;
                    ilist_t *a2;
                    for (a2 = block1->list->begin;a2 != block1->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FUN)
                        {
                            node_fun_t *func1 = (node_fun_t *)item2->value;
                            if (syntax_idstrcmp(func1->key, "||") == 1)
                            {
                                node_t *nps1 = func1->parameters;
                                node_t *nas2 = syntax_arguments_from_nodes(program, binary->right->parent, 1, binary->right);
                                if (nas2 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                int32_t r2 = syntax_eqaul_psas(program, nps1, nas2);
                                if (r2 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r2 == 1)
                                {
                                    ilist_t *il1 = list_rpush(response, func1->result);
                                    if (il1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    list_destroy(response1);
                                    return 1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    syntax_error(program, item1, "not a class");
                    return -1;
                }
            }
        }
        list_destroy(response1);
        return 0;
    }
    else
    {
        return syntax_logical_and(program, node, response);
    }
}

static int32_t
syntax_expression(program_t *program, node_t *node, list_t *response)
{
    return syntax_logical_or(program, node, response);
}

































































static int32_t
syntax_eqaul_gsgs(program_t *program, node_t *ngs1, node_t *ngs2)
{
   if (ngs1 == NULL)
    {
        if (ngs2 == NULL)
        {
            return 1;
        }
        else
        {
            node_block_t *bgs2 = (node_block_t *)ngs2->value;
            ilist_t *a2;
            for (a2 = bgs2->list->begin;a2 != bgs2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;
                if (item2->kind == NODE_KIND_GENERIC)
                {
                    node_generic_t *generic2 = (node_generic_t *)item2->value;
                    if (generic2->value == NULL)
                    {
                        return 0;
                    }
                }
            }
            return 1;
        }
    }
    else
    {
        if (ngs2 == NULL)
        {
            node_block_t *bps1 = (node_block_t *)ngs1->value;
            ilist_t *a1;
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_GENERIC)
                {
                    node_generic_t *generic1 = (node_generic_t *)item1->value;
                    if (generic1->value == NULL)
                    {
                        return 0;
                    }
                }
            }
            return 1;
        }
        else
        {
            uint64_t cnt1 = 0, cnt2 = 0;
            cnt1 = 0;

            node_block_t *bps1 = (node_block_t *)ngs1->value;
            ilist_t *a1;
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_GENERIC)
                {
                    cnt1 += 1;
                    cnt2 = 0;
                    node_generic_t *generic1 = (node_generic_t *)item1->value;
                    node_block_t *bgs2 = (node_block_t *)ngs2->value;
                    ilist_t *a2;
                    for (a2 = bgs2->list->begin;a2 != bgs2->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_GENERIC)
                        {
                            cnt2 += 1;
                            if (cnt2 < cnt1)
                            {
                                continue;
                            }
                            node_generic_t *generic2 = (node_generic_t *)item2->value;
                            
                            if (generic1->type != NULL)
                            {
                                if (generic2->type != NULL)
                                {
                                    list_t *response1 = list_create();
                                    if (response1 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    
                                    int32_t r1 = syntax_postfix(program, generic1->type, response1, item1);
                                    if (r1 == -1)
                                    {
                                        return -1;
                                    }
                                    else
                                    if (r1 == 0)
                                    {
                                        syntax_error(program, generic1->type, "reference not found");
                                        return -1;
                                    }
                                    else
                                    if (r1 == 1)
                                    {
                                        ilist_t *b1;
                                        for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                        {
                                            node_t *item3 = (node_t *)b1->value;

                                            list_t *response2 = list_create();
                                            if (response2 == NULL)
                                            {
                                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                return -1;
                                            }
                                            
                                            int32_t r2 = syntax_postfix(program, generic2->type, response2, item2);
                                            if (r2 == -1)
                                            {
                                                return -1;
                                            }
                                            else
                                            if (r2 == 0)
                                            {
                                                syntax_error(program, generic2->type, "reference not found");
                                                return -1;
                                            }
                                            else
                                            if (r2 == 1)
                                            {
                                                ilist_t *b2;
                                                for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                                {
                                                    node_t *item4 = (node_t *)b2->value;
                                                    int32_t r3 = syntax_subset(program, item3, item4);
                                                    if (r3 == -1)
                                                    {
                                                        return -1;
                                                    }
                                                    else
                                                    if (r3 == 0)
                                                    {
                                                        r3 = syntax_subset(program, item4, item3);
                                                        if (r3 == -1)
                                                        {
                                                            return -1;
                                                        }
                                                        else
                                                        if (r3 == 0)
                                                        {
                                                            list_destroy(response2);
                                                            list_destroy(response1);
                                                            goto region_by_name_check;
                                                        }
                                                        
                                                    }
                                                }
                                            }
                                            list_destroy(response2);
                                        }
                                    
                                        list_destroy(response1);
                                    }
                               }
                            }
                        }
                    }

                    if (cnt1 > cnt2)
                    {
                        if (generic1->value == NULL)
                        {
                            goto region_by_name_check;
                        }
                    }
                }
            }

            cnt2 = 0;
            node_block_t *bgs2 = (node_block_t *)ngs2->value;
            ilist_t *a2;
            for (a2 = bgs2->list->begin;a2 != bgs2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;
                if (item2->kind == NODE_KIND_GENERIC)
                {
                    cnt2 += 1;
                    if (cnt1 > cnt2)
                    {
                        node_generic_t *generic2 = (node_generic_t *)item2->value;
                        if (generic2->value == NULL)
                        {
                            goto region_by_name_check;
                        }
                    }
                }
            }

            return 1;

            region_by_name_check:
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_GENERIC)
                {
                    node_generic_t *generic1 = (node_generic_t *)item1->value;

                    int32_t found = 0;
                    node_block_t *bgs2 = (node_block_t *)ngs2->value;
                    ilist_t *a2;
                    for (a2 = bgs2->list->begin;a2 != bgs2->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_GENERIC)
                        {
                            node_generic_t *generic2 = (node_generic_t *)item2->value;
                            if (syntax_idcmp(generic1->key, generic2->key) == 1)
                            {
                                found = 1;
                                if (generic1->type != NULL)
                                {
                                    if (generic2->type != NULL)
                                    {
                                        list_t *response1 = list_create();
                                        if (response1 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }

                                        int32_t r1 = syntax_postfix(program, generic1->type, response1, item1);
                                        if (r1 == -1)
                                        {
                                            return -1;
                                        }
                                        else
                                        if (r1 == 0)
                                        {
                                            syntax_error(program, generic1->type, "reference not found");
                                            return -1;
                                        }
                                        else
                                        if (r1 == 1)
                                        {
                                            ilist_t *b1;
                                            for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                            {
                                                node_t *item3 = (node_t *)b1->value;

                                                list_t *response2 = list_create();
                                                if (response2 == NULL)
                                                {
                                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                    return -1;
                                                }
                                                
                                                int32_t r2 = syntax_postfix(program, generic2->type, response2, item2);
                                                if (r2 == -1)
                                                {
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 0)
                                                {
                                                    syntax_error(program, generic2->type, "reference not found");
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 1)
                                                {
                                                    ilist_t *b2;
                                                    for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                                    {
                                                        node_t *item4 = (node_t *)b2->value;
                                                        
                                                        int32_t r3 = syntax_subset(program, item3, item4);
                                                        if (r3 == -1)
                                                        {
                                                            return -1;
                                                        }
                                                        else
                                                        if (r3 == 0)
                                                        {
                                                            r3 = syntax_subset(program, item4, item3);
                                                            if (r3 == -1)
                                                            {
                                                                return -1;
                                                            }
                                                            else
                                                            if (r3 == 0)
                                                            {
                                                                list_destroy(response2);
                                                                list_destroy(response1);
                                                                return 0;
                                                            }
                                                        }
                                                    }
                                                }
                                                list_destroy(response2);
                                            }
                                        }
                                        
                                        list_destroy(response1);
                                    }
                                }
                            }
                        }
                    }

                    if (found == 0)
                    {
                        if (generic1->value == NULL)
                        {
                            return 0;
                        }
                    }
                }
            }

            bgs2 = (node_block_t *)ngs2->value;
            for (a2 = bgs2->list->begin;a2 != bgs2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;
                if (item2->kind == NODE_KIND_GENERIC)
                {
                    node_generic_t *generic2 = (node_generic_t *)item2->value;

                    int32_t found = 0;
                    for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
                    {
                        node_t *item1 = (node_t *)a1->value;
                        if (item1->kind == NODE_KIND_GENERIC)
                        {
                            node_generic_t *generic1 = (node_generic_t *)item1->value;

                            if (syntax_idcmp(generic1->key, generic2->key) == 1)
                            {
                                found = 1;
                                if (generic1->type != NULL)
                                {
                                    if (generic2->type != NULL)
                                    {
                                        list_t *response1 = list_create();
                                        if (response1 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }

                                        int32_t r1 = syntax_postfix(program, generic1->type, response1, item1);
                                        if (r1 == -1)
                                        {
                                            return -1;
                                        }
                                        else
                                        if (r1 == 0)
                                        {
                                            syntax_error(program, generic1->type, "reference not found");
                                            return -1;
                                        }
                                        else
                                        if (r1 == 1)
                                        {
                                            ilist_t *b1;
                                            for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                            {
                                                node_t *item3 = (node_t *)b1->value;

                                                list_t *response2 = list_create();
                                                if (response2 == NULL)
                                                {
                                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                    return -1;
                                                }
                                                
                                                int32_t r2 = syntax_postfix(program, generic2->type, response2, item2);
                                                if (r2 == -1)
                                                {
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 0)
                                                {
                                                    syntax_error(program, generic2->type, "reference not found");
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 1)
                                                {
                                                    ilist_t *b2;
                                                    for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                                    {
                                                        node_t *item4 = (node_t *)b2->value;
                                                        
                                                        int32_t r3 = syntax_subset(program, item3, item4);
                                                        if (r3 == -1)
                                                        {
                                                            return -1;
                                                        }
                                                        else
                                                        if (r3 == 0)
                                                        {
                                                            r3 = syntax_subset(program, item4, item3);
                                                            if (r3 == -1)
                                                            {
                                                                return -1;
                                                            }
                                                            else
                                                            if (r3 == 0)
                                                            {
                                                                list_destroy(response2);
                                                                list_destroy(response1);
                                                                return 0;
                                                            }
                                                        }
                                                    }
                                                }
                                                list_destroy(response2);
                                            }
                                        }
                                        
                                        list_destroy(response1);
                                    }
                                }
                            }
                        }
                    }

                    if (found == 0)
                    {
                        if (generic2->value == NULL)
                        {
                            return 0;
                        }
                    }
                }
            }

            return 1;
        }
    }
    return 0;
}

static int32_t
syntax_eqaul_psps(program_t *program, node_t *nps1, node_t *nps2)
{
    if (nps1 == NULL)
    {
        if (nps2 == NULL)
        {
            return 1;
        }
        else
        {
            node_block_t *bps2 = (node_block_t *)nps2->value;
            ilist_t *a2;
            for (a2 = bps2->list->begin;a2 != bps2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;
                if (item2->kind == NODE_KIND_PARAMETER)
                {
                    node_parameter_t *parameter2 = (node_parameter_t *)item2->value;
                    if (parameter2->value == NULL)
                    {
                        return 0;
                    }
                }
            }
            return 1;
        }
    }
    else
    {
        if (nps2 == NULL)
        {
            node_block_t *bps1 = (node_block_t *)nps1->value;
            ilist_t *a1;
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_PARAMETER)
                {
                    node_parameter_t *parameter1 = (node_parameter_t *)item1->value;
                    if (parameter1->value == NULL)
                    {
                        return 0;
                    }
                }
            }
            return 1;
        }
        else
        {
            uint64_t cnt1, cnt2;
            cnt1 = 0;

            node_block_t *bps1 = (node_block_t *)nps1->value;
            ilist_t *a1;
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_PARAMETER)
                {
                    cnt1 += 1;
                    cnt2 = 0;
                    node_parameter_t *parameter1 = (node_parameter_t *)item1->value;
                    node_block_t *bps2 = (node_block_t *)nps2->value;
                    ilist_t *a2;
                    for (a2 = bps2->list->begin;a2 != bps2->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_PARAMETER)
                        {
                            cnt2 += 1;
                            if (cnt2 < cnt1)
                            {
                                continue;
                            }
                            node_parameter_t *parameter2 = (node_parameter_t *)item2->value;
                            
                            list_t *response1 = list_create();
                            if (response1 == NULL)
                            {
                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                return -1;
                            }
                            
                            int32_t r1 = syntax_postfix(program, parameter1->type, response1, item1);
                            if (r1 == -1)
                            {
                                return -1;
                            }
                            else
                            if (r1 == 0)
                            {
                                syntax_error(program, parameter1->type, "reference not found");
                                return -1;
                            }
                            else
                            if (r1 == 1)
                            {
                                ilist_t *b1;
                                for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                {
                                    node_t *item3 = (node_t *)b1->value;

                                    list_t *response2 = list_create();
                                    if (response2 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                    
                                    int32_t r2 = syntax_postfix(program, parameter2->type, response2, item2);
                                    if (r2 == -1)
                                    {
                                        return -1;
                                    }
                                    else
                                    if (r2 == 0)
                                    {
                                        syntax_error(program, parameter2->type, "reference not found");
                                        return -1;
                                    }
                                    else
                                    if (r2 == 1)
                                    {
                                        ilist_t *b2;
                                        for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                        {
                                            node_t *item4 = (node_t *)b2->value;
                                            if (item3->id != item4->id)
                                            {
                                                list_destroy(response2);
                                                list_destroy(response1);
                                                goto region_by_name_check;
                                            }
                                        }
                                    }
                                     list_destroy(response2);
                                }
                               
                                list_destroy(response1);
                            }
                        
                        }
                    }

                    if (cnt1 > cnt2)
                    {
                        if (parameter1->value == NULL)
                        {
                            goto region_by_name_check;
                        }
                    }
                }
            }

            cnt2 = 0;
            node_block_t *bps2 = (node_block_t *)nps2->value;
            ilist_t *a2;
            for (a2 = bps2->list->begin;a2 != bps2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;
                if (item2->kind == NODE_KIND_PARAMETER)
                {
                    cnt2 += 1;
                    if (cnt1 > cnt2)
                    {
                        node_parameter_t *parameter2 = (node_parameter_t *)item2->value;
                        if (parameter2->value == NULL)
                        {
                            goto region_by_name_check;
                        }
                    }
                }
            }

            return 1;
            
            region_by_name_check:
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_PARAMETER)
                {
                    node_parameter_t *parameter1 = (node_parameter_t *)item1->value;

                    int32_t found = 0;
                    node_block_t *bps2 = (node_block_t *)nps2->value;
                    ilist_t *a2;
                    for (a2 = bps2->list->begin;a2 != bps2->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_PARAMETER)
                        {
                            node_parameter_t *parameter2 = (node_parameter_t *)item2->value;
                            if (syntax_idcmp(parameter1->key, parameter2->key) == 1)
                            {
                                found = 1;
                                list_t *response1 = list_create();
                                if (response1 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                
                                int32_t r1 = syntax_postfix(program, parameter1->type, response1, item1);
                                if (r1 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r1 == 0)
                                {
                                    syntax_error(program, parameter1->type, "reference not found");
                                    return -1;
                                }
                                else
                                if (r1 == 1)
                                {
                                    ilist_t *b1;
                                    for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                    {
                                        node_t *item3 = (node_t *)b1->value;

                                        list_t *response2 = list_create();
                                        if (response2 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }
                                        
                                        int32_t r2 = syntax_postfix(program, parameter2->type, response2, item2);
                                        if (r2 == -1)
                                        {
                                            return -1;
                                        }
                                        else
                                        if (r2 == 0)
                                        {
                                            syntax_error(program, parameter2->type, "reference not found");
                                            return -1;
                                        }
                                        else
                                        if (r2 == 1)
                                        {
                                            ilist_t *b2;
                                            for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                            {
                                                node_t *item4 = (node_t *)b2->value;
                                                
                                                if (item3->id != item4->id)
                                                {
                                                    list_destroy(response2);
                                                    list_destroy(response1);
                                                    return 0;
                                                }
                                            }
                                        }
                                        list_destroy(response2);
                                    }
                                    list_destroy(response1);
                                }

                                list_destroy(response1);
                            }
                        }
                    }

                    if (found == 0)
                    {
                        if (parameter1->value == NULL)
                        {
                            return 0;
                        }
                    }
                }
            }
            

            bps2 = (node_block_t *)nps2->value;
            for (a2 = bps2->list->begin;a2 != bps2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;
                if (item2->kind == NODE_KIND_PARAMETER)
                {
                    node_parameter_t *parameter2 = (node_parameter_t *)item2->value;

                    int32_t found = 0;
                    for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
                    {
                        node_t *item1 = (node_t *)a1->value;
                        if (item1->kind == NODE_KIND_PARAMETER)
                        {
                            node_parameter_t *parameter1 = (node_parameter_t *)item1->value;

                            if (syntax_idcmp(parameter1->key, parameter2->key) == 1)
                            {
                                found = 1;
                                list_t *response1 = list_create();
                                if (response1 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                
                                int32_t r1 = syntax_postfix(program, parameter1->type, response1, item1);
                                if (r1 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r1 == 0)
                                {
                                    syntax_error(program, parameter1->type, "reference not found");
                                    return -1;
                                }
                                else
                                if (r1 == 1)
                                {
                                    ilist_t *b1;
                                    for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                    {
                                        node_t *item3 = (node_t *)b1->value;

                                        list_t *response2 = list_create();
                                        if (response2 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }
                                        
                                        int32_t r2 = syntax_postfix(program, parameter2->type, response2, item2);
                                        if (r2 == -1)
                                        {
                                            return -1;
                                        }
                                        else
                                        if (r2 == 0)
                                        {
                                            syntax_error(program, parameter2->type, "reference not found");
                                            return -1;
                                        }
                                        else
                                        if (r2 == 1)
                                        {
                                            ilist_t *b2;
                                            for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                            {
                                                node_t *item4 = (node_t *)b2->value;
                                                
                                                if (item3->id != item4->id)
                                                {
                                                    list_destroy(response2);
                                                    list_destroy(response1);
                                                    return 0;
                                                }
                                            }
                                        }
                                        list_destroy(response2);
                                    }
                                    list_destroy(response1);
                                }

                                list_destroy(response1);
                            }
                        }
                    }

                    if (found == 0)
                    {
                        if (parameter2->value == NULL)
                        {
                            return 0;
                        }
                    }
                }
            }

            return 1;
        }
    }

    return 0;
}

static int32_t
syntax_eqaul_psas(program_t *program, node_t *nps1, node_t *nas2)
{
   if (nps1 == NULL)
    {
        if (nas2 == NULL)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        if (nas2 == NULL)
        {
            node_block_t *bps1 = (node_block_t *)nps1->value;
            ilist_t *a1;
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_PARAMETER)
                {
                    node_parameter_t *parameter1 = (node_parameter_t *)item1->value;
                    if (parameter1->value == NULL)
                    {
                        return 0;
                    }
                }
            }
            return 1;
        }
        else
        {
            uint64_t cnt1 = 0, cnt2 = 0;
            cnt1 = 0;

            node_block_t *bps1 = (node_block_t *)nps1->value;
            ilist_t *a1;
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_PARAMETER)
                {
                    cnt1 += 1;
                    cnt2 = 0;
                    node_parameter_t *parameter1 = (node_parameter_t *)item1->value;
                    node_block_t *bas2 = (node_block_t *)nas2->value;
                    ilist_t *a2;
                    for (a2 = bas2->list->begin;a2 != bas2->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_ARGUMENT)
                        {
                            cnt2 += 1;
                            if (cnt2 < cnt1)
                            {
                                continue;
                            }
                            node_pair_t *argument2 = (node_pair_t *)item2->value;
                            
                            if (parameter1->type != NULL)
                            {
                                list_t *response1 = list_create();
                                if (response1 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                
                                int32_t r1 = syntax_postfix(program, parameter1->type, response1, item1);
                                if (r1 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r1 == 0)
                                {
                                    syntax_error(program, parameter1->type, "reference not found");
                                    return -1;
                                }
                                else
                                if (r1 == 1)
                                {
                                    ilist_t *b1;
                                    for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                    {
                                        node_t *item3 = (node_t *)b1->value;

                                        list_t *response2 = list_create();
                                        if (response2 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }
                                        
                                        int32_t r2 = syntax_postfix(program, argument2->value, response2, item2);
                                        if (r2 == -1)
                                        {
                                            return -1;
                                        }
                                        else
                                        if (r2 == 0)
                                        {
                                            syntax_error(program, argument2->value, "reference not found");
                                            return -1;
                                        }
                                        else
                                        if (r2 == 1)
                                        {
                                            ilist_t *b2;
                                            for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                            {
                                                node_t *item4 = (node_t *)b2->value;
                                                if (item3->id != item4->id)
                                                {
                                                    goto region_by_name_check;
                                                    
                                                }
                                            }
                                        }
                                        list_destroy(response2);
                                    }
                                
                                    list_destroy(response1);
                                }
                            }
                        }
                    }

                    if (cnt1 > cnt2)
                    {
                        if (parameter1->value == NULL)
                        {
                            goto region_by_name_check;
                        }
                    }
                }
            }

            cnt2 = 0;
            node_block_t *bas2 = (node_block_t *)nas2->value;
            ilist_t *a2;
            for (a2 = bas2->list->begin;a2 != bas2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;
                if (item2->kind == NODE_KIND_PARAMETER)
                {
                    cnt2 += 1;
                    if (cnt1 > cnt2)
                    {
                        goto region_by_name_check;
                    }
                }
            }

            return 1;

            region_by_name_check:
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_PARAMETER)
                {
                    node_parameter_t *parameter1 = (node_parameter_t *)item1->value;

                    int32_t found = 0;
                    node_block_t *bas2 = (node_block_t *)nas2->value;
                    ilist_t *a2;
                    for (a2 = bas2->list->begin;a2 != bas2->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_ARGUMENT)
                        {
                            node_pair_t *argument2 = (node_pair_t *)item2->value;
                            if (syntax_idcmp(parameter1->key, argument2->key) == 1)
                            {
                                found = 1;
                                if (parameter1->type != NULL)
                                {
                                    if (argument2->value != NULL)
                                    {
                                        list_t *response1 = list_create();
                                        if (response1 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }

                                        int32_t r1 = syntax_postfix(program, parameter1->type, response1, item1);
                                        if (r1 == -1)
                                        {
                                            return -1;
                                        }
                                        else
                                        if (r1 == 0)
                                        {
                                            syntax_error(program, parameter1->type, "reference not found");
                                            return -1;
                                        }
                                        else
                                        if (r1 == 1)
                                        {
                                            ilist_t *b1;
                                            for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                            {
                                                node_t *item3 = (node_t *)b1->value;

                                                list_t *response2 = list_create();
                                                if (response2 == NULL)
                                                {
                                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                    return -1;
                                                }
                                                
                                                int32_t r2 = syntax_postfix(program, argument2->value, response2, item2);
                                                if (r2 == -1)
                                                {
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 0)
                                                {
                                                    syntax_error(program, argument2->value, "reference not found");
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 1)
                                                {
                                                    ilist_t *b2;
                                                    for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                                    {
                                                        node_t *item4 = (node_t *)b2->value;
                                                        
                                                        if (item3->id != item4->id)
                                                        {
                                                            return 0;
                                                        }
                                                    }
                                                }
                                                list_destroy(response2);
                                            }
                                        }
                                        
                                        list_destroy(response1);
                                    }
                                }
                            }
                        }
                    }

                    if (found == 0)
                    {
                        if (parameter1->value == NULL)
                        {
                            return 0;
                        }
                    }
                }
            }

            bas2 = (node_block_t *)nas2->value;
            for (a2 = bas2->list->begin;a2 != bas2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;
                if (item2->kind == NODE_KIND_ARGUMENT)
                {
                    node_pair_t *argument2 = (node_pair_t *)item2->value;

                    int32_t found = 0;
                    for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
                    {
                        node_t *item1 = (node_t *)a1->value;
                        if (item1->kind == NODE_KIND_PARAMETER)
                        {
                            node_parameter_t *parameter1 = (node_parameter_t *)item1->value;

                            if (syntax_idcmp(parameter1->key, argument2->key) == 1)
                            {
                                found = 1;
                                if (parameter1->type != NULL)
                                {
                                    if (argument2->value != NULL)
                                    {
                                        list_t *response1 = list_create();
                                        if (response1 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }

                                        int32_t r1 = syntax_postfix(program, parameter1->type, response1, item1);
                                        if (r1 == -1)
                                        {
                                            return -1;
                                        }
                                        else
                                        if (r1 == 0)
                                        {
                                            syntax_error(program, parameter1->type, "reference not found");
                                            return -1;
                                        }
                                        else
                                        if (r1 == 1)
                                        {
                                            ilist_t *b1;
                                            for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                            {
                                                node_t *item3 = (node_t *)b1->value;

                                                list_t *response2 = list_create();
                                                if (response2 == NULL)
                                                {
                                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                    return -1;
                                                }
                                                
                                                int32_t r2 = syntax_postfix(program, argument2->value, response2, item2);
                                                if (r2 == -1)
                                                {
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 0)
                                                {
                                                    syntax_error(program, argument2->value, "reference not found");
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 1)
                                                {
                                                    ilist_t *b2;
                                                    for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                                    {
                                                        node_t *item4 = (node_t *)b2->value;
                                                        
                                                        if (item3->id != item4->id)
                                                        {
                                                            return 0;
                                                        }
                                                    }
                                                }
                                                list_destroy(response2);
                                            }
                                        }
                                        
                                        list_destroy(response1);
                                    }
                                }
                            }
                        }
                    }

                    if (found == 0)
                    {
                        return 0;
                    }
                }
            }

            return 1;
        }
    }
    return 0;
}

static int32_t
syntax_eqaul_gsfs(program_t *program, node_t *ngs1, node_t *nfs2)
{
    if (ngs1 == NULL)
    {
        if (nfs2 == NULL)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        if (nfs2 == NULL)
        {
            node_block_t *bps1 = (node_block_t *)ngs1->value;
            ilist_t *a1;
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_GENERIC)
                {
                    node_generic_t *generic1 = (node_generic_t *)item1->value;
                    if (generic1->value == NULL)
                    {
                        return 0;
                    }
                }
            }
            return 1;
        }
        else
        {
            uint64_t cnt1 = 0, cnt2 = 0;
            cnt1 = 0;

            node_block_t *bps1 = (node_block_t *)ngs1->value;
            ilist_t *a1;
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_GENERIC)
                {
                    cnt1 += 1;
                    cnt2 = 0;
                    node_generic_t *generic1 = (node_generic_t *)item1->value;
                    node_block_t *bfs2 = (node_block_t *)nfs2->value;
                    ilist_t *a2;
                    for (a2 = bfs2->list->begin;a2 != bfs2->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FIELD)
                        {
                            cnt2 += 1;
                            if (cnt2 < cnt1)
                            {
                                continue;
                            }
                            node_pair_t *field2 = (node_pair_t *)item2->value;
                            
                            if (generic1->type != NULL)
                            {
                                list_t *response1 = list_create();
                                if (response1 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                
                                int32_t r1 = syntax_postfix(program, generic1->type, response1, item1);
                                if (r1 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r1 == 0)
                                {
                                    syntax_error(program, generic1->type, "reference not found");
                                    return -1;
                                }
                                else
                                if (r1 == 1)
                                {
                                    ilist_t *b1;
                                    for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                    {
                                        node_t *item3 = (node_t *)b1->value;

                                        list_t *response2 = list_create();
                                        if (response2 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }
                                        
                                        int32_t r2 = syntax_postfix(program, field2->key, response2, item2);
                                        if (r2 == -1)
                                        {
                                            return -1;
                                        }
                                        else
                                        if (r2 == 0)
                                        {
                                            syntax_error(program, field2->key, "reference not found");
                                            return -1;
                                        }
                                        else
                                        if (r2 == 1)
                                        {
                                            ilist_t *b2;
                                            for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                            {
                                                node_t *item4 = (node_t *)b2->value;
                                                int32_t r3 = syntax_subset(program, item3, item4);
                                                if (r3 == -1)
                                                {
                                                    return -1;
                                                }
                                                else
                                                if (r3 == 0)
                                                {
                                                    r3 = syntax_subset(program, item4, item3);
                                                    if (r3 == -1)
                                                    {
                                                        return -1;
                                                    }
                                                    else
                                                    if (r3 == 0)
                                                    {
                                                        list_destroy(response2);
                                                        list_destroy(response1);
                                                        goto region_by_name_check;
                                                    }
                                                    
                                                }
                                            }
                                        }
                                        list_destroy(response2);
                                    }
                                
                                    list_destroy(response1);
                                }
                            }
                        }
                    }

                    if (cnt1 > cnt2)
                    {
                        if (generic1->value == NULL)
                        {
                            goto region_by_name_check;
                        }
                    }
                }
            }

            cnt2 = 0;
            node_block_t *bfs2 = (node_block_t *)nfs2->value;
            ilist_t *a2;
            for (a2 = bfs2->list->begin;a2 != bfs2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;
                if (item2->kind == NODE_KIND_FIELD)
                {
                    cnt2 += 1;
                    if (cnt1 > cnt2)
                    {
                        goto region_by_name_check;
                    }
                }
            }

            return 1;
            
            region_by_name_check:
            for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
            {
                node_t *item1 = (node_t *)a1->value;
                if (item1->kind == NODE_KIND_GENERIC)
                {
                    node_generic_t *generic1 = (node_generic_t *)item1->value;

                    int32_t found = 0;
                    node_block_t *bps2 = (node_block_t *)nfs2->value;
                    ilist_t *a2;
                    for (a2 = bps2->list->begin;a2 != bps2->list->end;a2 = a2->next)
                    {
                        node_t *item2 = (node_t *)a2->value;
                        if (item2->kind == NODE_KIND_FIELD)
                        {
                            node_pair_t *field2 = (node_pair_t *)item2->value;
                            if (syntax_idcmp(generic1->key, field2->key) == 1)
                            {
                                found = 1;
                                if (generic1->type != NULL)
                                {
                                    if (field2->value != NULL)
                                    {
                                        list_t *response1 = list_create();
                                        if (response1 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }

                                        int32_t r1 = syntax_postfix(program, generic1->type, response1, item1);
                                        if (r1 == -1)
                                        {
                                            return -1;
                                        }
                                        else
                                        if (r1 == 0)
                                        {
                                            syntax_error(program, generic1->type, "reference not found");
                                            return -1;
                                        }
                                        else
                                        if (r1 == 1)
                                        {
                                            ilist_t *b1;
                                            for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                            {
                                                node_t *item3 = (node_t *)b1->value;

                                                list_t *response2 = list_create();
                                                if (response2 == NULL)
                                                {
                                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                    return -1;
                                                }
                                                
                                                int32_t r2 = syntax_postfix(program, field2->value, response2, item2);
                                                if (r2 == -1)
                                                {
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 0)
                                                {
                                                    syntax_error(program, field2->value, "reference not found");
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 1)
                                                {
                                                    ilist_t *b2;
                                                    for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                                    {
                                                        node_t *item4 = (node_t *)b2->value;
                                                        
                                                        int32_t r3 = syntax_subset(program, item3, item4);
                                                        if (r3 == -1)
                                                        {
                                                            return -1;
                                                        }
                                                        else
                                                        if (r3 == 0)
                                                        {
                                                            r3 = syntax_subset(program, item4, item3);
                                                            if (r3 == -1)
                                                            {
                                                                return -1;
                                                            }
                                                            else
                                                            if (r3 == 0)
                                                            {
                                                                list_destroy(response2);
                                                                list_destroy(response1);
                                                                return 0;
                                                            }
                                                        }
                                                    }
                                                }
                                                list_destroy(response2);
                                            }
                                        }
                                        
                                        list_destroy(response1);
                                    }
                                }
                            }
                        }
                    }

                    if (found == 0)
                    {
                        if (generic1->value == NULL)
                        {
                            return 0;
                        }
                    }
                }
            }

            bfs2 = (node_block_t *)nfs2->value;
            for (a2 = bfs2->list->begin;a2 != bfs2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;
                if (item2->kind == NODE_KIND_FIELD)
                {
                    node_pair_t *field2 = (node_pair_t *)item2->value;

                    int32_t found = 0;
                    for (a1 = bps1->list->begin;a1 != bps1->list->end;a1 = a1->next)
                    {
                        node_t *item1 = (node_t *)a1->value;
                        if (item1->kind == NODE_KIND_GENERIC)
                        {
                            node_generic_t *generic1 = (node_generic_t *)item1->value;

                            if (syntax_idcmp(generic1->key, field2->key) == 1)
                            {
                                found = 1;
                                if (generic1->type != NULL)
                                {
                                    if (field2->value != NULL)
                                    {
                                        list_t *response1 = list_create();
                                        if (response1 == NULL)
                                        {
                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                            return -1;
                                        }

                                        int32_t r1 = syntax_postfix(program, generic1->type, response1, item1);
                                        if (r1 == -1)
                                        {
                                            return -1;
                                        }
                                        else
                                        if (r1 == 0)
                                        {
                                            syntax_error(program, generic1->type, "reference not found");
                                            return -1;
                                        }
                                        else
                                        if (r1 == 1)
                                        {
                                            ilist_t *b1;
                                            for (b1 = response1->begin;b1 != response1->end;b1 = b1->next)
                                            {
                                                node_t *item3 = (node_t *)b1->value;

                                                list_t *response2 = list_create();
                                                if (response2 == NULL)
                                                {
                                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                    return -1;
                                                }
                                                
                                                int32_t r2 = syntax_postfix(program, field2->value, response2, item2);
                                                if (r2 == -1)
                                                {
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 0)
                                                {
                                                    syntax_error(program, field2->value, "reference not found");
                                                    return -1;
                                                }
                                                else
                                                if (r2 == 1)
                                                {
                                                    ilist_t *b2;
                                                    for (b2 = response2->begin;b2 != response2->end;b2 = b2->next)
                                                    {
                                                        node_t *item4 = (node_t *)b2->value;
                                                        
                                                        int32_t r3 = syntax_subset(program, item3, item4);
                                                        if (r3 == -1)
                                                        {
                                                            return -1;
                                                        }
                                                        else
                                                        if (r3 == 0)
                                                        {
                                                            r3 = syntax_subset(program, item4, item3);
                                                            if (r3 == -1)
                                                            {
                                                                return -1;
                                                            }
                                                            else
                                                            if (r3 == 0)
                                                            {
                                                                list_destroy(response2);
                                                                list_destroy(response1);
                                                                return 0;
                                                            }
                                                        }
                                                    }
                                                }
                                                list_destroy(response2);
                                            }
                                        }
                                        
                                        list_destroy(response1);
                                    }
                                }
                            }
                        }
                    }

                    if (found == 0)
                    {
                        return 0;
                    }
                }
            }

            return 1;
        }
    }
    return 1;
}


static int32_t
syntax_select(program_t *program, node_t *root, char *name, list_t *response, node_t *applicant)
{
    if (root->kind == NODE_KIND_CLASS)
    {
        node_class_t *class1 = (node_class_t *)root->value;
        node_t *node1 = class1->block;
        node_block_t *block1 = (node_block_t *)node1->value;
        ilist_t *a1;
        for (a1 = block1->list->begin;a1 != block1->list->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            if (item1->kind == NODE_KIND_CLASS)
            {
                node_class_t *class2 = (node_class_t *)item1->value;
                if (syntax_idstrcmp(class2->key, name) == 1)
                {
                    ilist_t *r1 = list_rpush(response, item1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_ENUM)
            {
                node_enum_t *enum1 = (node_enum_t *)item1->value;
                if (syntax_idstrcmp(enum1->key, name) == 1)
                {
                    ilist_t *r1 = list_rpush(response, item1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
        }

        if (class1->generics != NULL)
        {
            node_t *node2 = class1->generics;
            node_block_t *block2 = (node_block_t *)node2->value;

            ilist_t *a2;
            for (a2 = block2->list->begin;a2 != block2->list->end;a2 = a2->next)
            {
                node_t *item2 = (node_t *)a2->value;

                if (item2->kind == NODE_KIND_GENERIC)
                {
                    node_generic_t *generic3 = (node_generic_t *)item2->value;
                    if (syntax_idstrcmp(generic3->key, name) == 1)
                    {
                        ilist_t *r1 = list_rpush(response, item2);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                    }
                }
            }
        }

        if ((class1->heritages != NULL) && (root->id != applicant->id))
        {
            node_t *base = class1->heritages;

            list_t *repository1 = list_create();
            if (repository1 == NULL)
            {
                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                return -1;
            }

            while (base != NULL)
            {

                node_block_t *block2 = (node_block_t *)base->value;

                ilist_t *a2;
                for (a2 = block2->list->begin;a2 != block2->list->end;a2 = a2->next)
                {
                    node_t *item2 = (node_t *)a2->value;

                    if (item2->kind == NODE_KIND_HERITAGE)
                    {
                        node_heritage_t *heritage3 = (node_heritage_t *)item2->value;
                        
                        list_t *response2 = list_create();
                        if (response2 == NULL)
                        {
                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                            return -1;
                        }
                        
                        int32_t r1 = syntax_postfix(program, heritage3->type, response2, root);
                        if (r1 == -1)
                        {
                            return -1;
                        }
                        else
                        if (r1 == 0)
                        {
                            syntax_error(program, heritage3->type, "reference not found");
                            return -1;
                        }
                        else
                        if (r1 == 1)
                        {
                            ilist_t *a3;
                            for (a3 = response2->begin;a3 != response2->end;a3 = a3->next)
                            {
                                node_t *item3 = (node_t *)a3->value;
                                if (item3->kind == NODE_KIND_CLASS)
                                {
                                    node_class_t *class4 = (node_class_t *)item3->value;
                                    node_t *node4 = class4->block;
                                    node_block_t *block4 = (node_block_t *)node4->value;

                                    ilist_t *a4;
                                    for (a4 = block4->list->begin;a4 != block4->list->end;a4 = a4->next)
                                    {
                                        node_t *item4 = (node_t *)a4->value;
                                        if (item4->kind == NODE_KIND_CLASS)
                                        {
                                            node_class_t *class5 = (node_class_t *)item4->value;
                                            if (syntax_idstrcmp(class5->key, name) == 1)
                                            {
                                                ilist_t *r1 = list_rpush(response, item4);
                                                if (r1 == NULL)
                                                {
                                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                    return -1;
                                                }
                                            }
                                        }
                                        else
                                        if (item4->kind == NODE_KIND_ENUM)
                                        {
                                            node_enum_t *enum1 = (node_enum_t *)item4->value;
                                            if (syntax_idstrcmp(enum1->key, name) == 1)
                                            {
                                                ilist_t *r1 = list_rpush(response, item4);
                                                if (r1 == NULL)
                                                {
                                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                    return -1;
                                                }
                                            }
                                        }
                                    }

                                    ilist_t *r2 = list_rpush(repository1, class4->heritages);
                                    if (r2 == NULL)
                                    {
                                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                        return -1;
                                    }
                                }
                            }
                        }

                        list_destroy(response2);
                    }
                }

                ilist_t *r1 = list_rpop(repository1);
                if (r1 != NULL)
                {
                    base = (node_t *)r1->value;
                    continue;
                }
                else
                {
                    base = NULL;
                    break;
                }

            }

            list_destroy(repository1);
        }
    }
    else
    if (root->kind == NODE_KIND_MODULE)
    {
        node_module_t *module1 = (node_module_t *)root->value;
        ilist_t *a1;
        for (a1 = module1->items->begin;a1 != module1->items->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            if (item1->kind == NODE_KIND_IMPORT)
            {
                node_import_t *import1 = (node_import_t *)item1->value;
                node_t *node2 = import1->packages;
                node_block_t *block2 = (node_block_t *)node2->value;

                ilist_t *a2;
                for (a2 = block2->list->begin;a2 != block2->list->end;a2 = a2->next)
                {
                    node_t *item2 = (node_t *)a2->value;
                    if (item2->kind == NODE_KIND_PACKAGE)
                    {
                        node_package_t *package2 = (node_package_t *)item2->value;
                        if (syntax_idstrcmp(package2->key, name) == 1)
                        {
                            ilist_t *r1 = list_rpush(response, item2);
                            if (r1 == NULL)
                            {
                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                return -1;
                            }
                        }
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_CLASS)
            {
                node_class_t *class2 = (node_class_t *)item1->value;
                if (syntax_idstrcmp(class2->key, name) == 1)
                {
                    ilist_t *r1 = list_rpush(response, item1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_ENUM)
            {
                node_enum_t *enum1 = (node_enum_t *)item1->value;
                if (syntax_idstrcmp(enum1->key, name) == 1)
                {
                    ilist_t *r1 = list_rpush(response, item1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
        }
    }

    if (root->parent != NULL)
    {
        return syntax_select(program, root->parent, name, response, applicant);
    }
    
    if (list_count(response) > 0)
    {
        return 1;
    }

    return 0;
}

static int32_t
syntax_id(program_t *program, node_t *node, list_t *response, node_t *applicant)
{
    node_basic_t *nb1 = (node_basic_t *)node->value;
    return syntax_select(program, node->parent, nb1->value, response, applicant);
}

static int32_t
syntax_array(program_t *program, node_t *node, list_t *response, node_t *applicant)
{
    ilist_t *r1 = list_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }
    return 1;
}

static int32_t
syntax_object(program_t *program, node_t *node, list_t *response, node_t *applicant)
{
    ilist_t *r1 = list_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }
    return 1;
}

static int32_t
syntax_primary(program_t *program, node_t *node, list_t *response, node_t *applicant)
{
    if (node->kind == NODE_KIND_ID)
    {
        return syntax_id(program, node, response, applicant);
    }
    else
    if (node->kind == NODE_KIND_ARRAY)
    {
        return syntax_array(program, node, response, applicant);
    }
    else
    if (node->kind == NODE_KIND_OBJECT)
    {
        return syntax_object(program, node, response, applicant);
    }
    else
    {
        syntax_error(program, node, "not a type");
        return -1;
    }
}

static int32_t
syntax_pseudonym(program_t *program, node_t *node, list_t *response, node_t *applicant)
{
    node_carrier_t *carrier = (node_carrier_t *)node->value;
    
    list_t *response1 = list_create();
    if (response1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }

    int32_t r1 = syntax_postfix(program, carrier->base, response1, node);
    if (r1 == -1)
    {
        return -1;
    }
    else
    if (r1 == 0)
    {
        syntax_error(program, carrier->base, "reference not found");
        return -1;
    }
    else
    if (r1 == 1)
    {
        ilist_t *a1;
        for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            if (item1->kind == NODE_KIND_CLASS)
            {
                node_class_t *class1 = (node_class_t *)item1->value;
                node_t *ngs1 = class1->generics;
                node_t *nfs2 = carrier->data;
                int32_t r1 = syntax_eqaul_gsfs(program, ngs1, nfs2);
                if (r1 == -1)
                {
                    return -1;
                }
                else
                if (r1 == 1)
                {
                    ilist_t *il1 = list_rpush(response, item1);
                    if (il1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
            else
            if (item1->kind == NODE_KIND_PACKAGE)
            {
                node_package_t *package2 = (node_package_t *)item1->value;
                node_t *ngs1 = package2->generics;
                node_t *nfs2 = carrier->data;
                int32_t r1 = syntax_eqaul_gsfs(program, ngs1, nfs2);
                if (r1 == -1)
                {
                    return -1;
                }
                else
                if (r1 == 1)
                {
                    ilist_t *il1 = list_rpush(response, item1);
                    if (il1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }
                }
            }
            else
            {
                syntax_error(program, item1, "not a class, in (%lld:%lld)",
                    node->position.line, node->position.column);
                return -1;
            }
        }
    }

    list_destroy(response1);

    if (list_count(response) > 0)
    {
        return 1;
    }

    return 0;
}

static int32_t
syntax_attribute(program_t *program, node_t *node, list_t *response, node_t *applicant)
{
    node_binary_t *basic = (node_binary_t *)node->value;
    
    list_t *response1 = list_create();
    if (response1 == NULL)
    {
        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
        return -1;
    }

    int32_t r1 = syntax_postfix(program, basic->left, response1, node);
    if (r1 == -1)
    {
        return -1;
    }
    else
    if (r1 == 0)
    {
        syntax_error(program, basic->left, "reference not found");
        return -1;
    }
    else
    if (r1 == 1)
    {
        ilist_t *a1;
        for (a1 = response1->begin;a1 != response1->end;a1 = a1->next)
        {
            node_t *item1 = (node_t *)a1->value;
            if (item1->kind == NODE_KIND_CLASS)
            {
                node_class_t *class2 = (node_class_t *)item1->value;
                node_t *node2 = class2->block;
                node_block_t *block2 = (node_block_t *)node2->value;
                ilist_t *a2;
                for (a2 = block2->list->begin;a2 != block2->list->end;a2 = a2->next)
                {
                    node_t *item2 = (node_t *)a2->value;
                    if (item2->kind == NODE_KIND_CLASS)
                    {
                        node_class_t *class2 = (node_class_t *)item2->value;
                        if (syntax_idcmp(basic->right, class2->key) == 1)
                        {
                            if ((class2->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
                            {
                                syntax_error(program, item2, "private access, in (%lld:%lld)",
                                    node->position.line, node->position.column);
                                return -1;
                            }
                            ilist_t *r2 = list_rpush(response, item2);
                            if (r2 == NULL)
                            {
                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                return -1;
                            }
                            list_destroy(response1);
                            return 1;
                        }
                    }
                    else
                    if (item2->kind == NODE_KIND_ENUM)
                    {
                        node_enum_t *enum1 = (node_enum_t *)item2->value;
                        if (syntax_idcmp(basic->right, enum1->key) == 1)
                        {
                            if ((enum1->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
                            {
                                syntax_error(program, item2, "private access, in (%lld:%lld)",
                                    node->position.line, node->position.column);
                                return -1;
                            }
                            ilist_t *r1 = list_rpush(response, item2);
                            if (r1 == NULL)
                            {
                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                return -1;
                            }
                            return 1;
                        }
                    }
                }

                if (class2->heritages != NULL)
                {
                    node_t *root = class2->heritages;
                    list_t *repository1 = list_create();
                    if (repository1 == NULL)
                    {
                        fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                        return -1;
                    }

                    while (root != NULL)
                    {
                        node_block_t *block3 = (node_block_t *)root->value;

                        ilist_t *a3;
                        for (a3 = block3->list->begin;a3 != block3->list->end;a3 = a3->next)
                        {
                            node_t *item3 = (node_t *)a3->value;
                            
                            if (item3->kind == NODE_KIND_HERITAGE)
                            {
                                node_heritage_t *heritage4 = (node_heritage_t *)item3->value;
                                
                                list_t *response4 = list_create();
                                if (response4 == NULL)
                                {
                                    fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                    return -1;
                                }
                                
                                int32_t r4 = syntax_postfix(program, heritage4->type, response4, node);
                                if (r4 == -1)
                                {
                                    return -1;
                                }
                                else
                                if (r4 == 0)
                                {
                                    syntax_error(program, heritage4->type, "reference not found");
                                    return -1;
                                }
                                else
                                if (r4 == 1)
                                {
                                    ilist_t *a5;
                                    for (a5 = response4->begin;a5 != response4->end;a5 = a5->next)
                                    {
                                        node_t *item5 = (node_t *)a5->value;
                                        
                                        if (item5->kind == NODE_KIND_CLASS)
                                        {
                                            node_class_t *class5 = (node_class_t *)item5->value;
                                            node_t *node5 = class5->block;
                                            node_block_t *block5 = (node_block_t *)node5->value;

                                            ilist_t *a6;
                                            for (a6 = block5->list->begin;a6 != block5->list->end;a6 = a6->next)
                                            {
                                                node_t *item6 = (node_t *)a6->value;
                                                if (item6->kind == NODE_KIND_CLASS)
                                                {
                                                    node_class_t *class6 = (node_class_t *)item6->value;
                                                    if (syntax_idcmp(class6->key, basic->right) == 1)
                                                    {
                                                        if ((class6->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
                                                        {
                                                            syntax_error(program, item6, "private access, in (%lld:%lld)",
                                                                node->position.line, node->position.column);
                                                            return -1;
                                                        }

                                                        if ((class6->flag & PARSER_MODIFIER_PROTECT) == PARSER_MODIFIER_PROTECT)
                                                        {
                                                            syntax_error(program, item6, "protect access, in (%lld:%lld)",
                                                                node->position.line, node->position.column);
                                                            return -1;
                                                        }

                                                        ilist_t *r6 = list_rpush(response, item6);
                                                        if (r6 == NULL)
                                                        {
                                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                            return -1;
                                                        }
                                                        list_destroy(response4);
                                                        return 1;
                                                    }
                                                }
                                                else
                                                if (item6->kind == NODE_KIND_ENUM)
                                                {
                                                    node_enum_t *enum1 = (node_enum_t *)item6->value;
                                                    if (syntax_idcmp(enum1->key, basic->right) == 1)
                                                    {
                                                        if ((enum1->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
                                                        {
                                                            syntax_error(program, item6, "private access, in (%lld:%lld)",
                                                                node->position.line, node->position.column);
                                                            return -1;
                                                        }

                                                        if ((enum1->flag & PARSER_MODIFIER_PROTECT) == PARSER_MODIFIER_PROTECT)
                                                        {
                                                            syntax_error(program, item6, "protect access, in (%lld:%lld)",
                                                                node->position.line, node->position.column);
                                                            return -1;
                                                        }

                                                        ilist_t *r1 = list_rpush(response, item6);
                                                        if (r1 == NULL)
                                                        {
                                                            fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                            return -1;
                                                        }
                                                        list_destroy(response4);
                                                        return 1;
                                                    }
                                                }
                                            }

                                            ilist_t *r3 = list_rpush(repository1, class5->heritages);
                                            if (r3 == NULL)
                                            {
                                                fprintf(stderr, "%s-(%u):unable to allocate memory\n", __FILE__, __LINE__);
                                                return -1;
                                            }
                                        }
                                    }
                                }

                                list_destroy(response4);
                            }
                        }
                    
                        ilist_t *r1 = list_rpop(repository1);
                        if (r1 != NULL)
                        {
                            root = (node_t *)r1->value;
                            continue;
                        }
                        else
                        {
                            root = NULL;
                            break;
                        }
                    }

                    list_destroy(repository1);
                }
            }
            else
            {
                syntax_error(program, item1, "not a class, in (%lld:%lld)",
                    node->position.line, node->position.column);
                return -1;
            }
        }
    }

    list_destroy(response1);

    return 0;
}

static int32_t
syntax_postfix(program_t *program, node_t *node, list_t *response, node_t *applicant)
{
    if (node->kind == NODE_KIND_ATTRIBUTE)
    {
        return syntax_attribute(program, node, response, applicant);
    }
    else
    if (node->kind == NODE_KIND_PSEUDONYM)
    {
        return syntax_pseudonym(program, node, response, applicant);
    }
    else
    {
        return syntax_primary(program, node, response, applicant);
    }
    
}

