
static response_t *
syntax_id(program_t *program, symbol_t *current)
{
	symbol_t *base = current->parent, *a;
	while(base)
	{
		for (a = base->begin;a != base->end;a = a->next)
		{
			if (symbol_check_type(a, SYMBOL_CLASS))
			{
				symbol_t *ak;
				ak = syntax_extract_with(a, SYMBOL_KEY);
				if (ak)
				{
					if (syntax_strcmp(current, ak) == 0)
					{
						response_t *response = response_create();
						if (response)
						{
							iresponse_t *iresponse;
							iresponse = response_rpush(response, a);
							if (iresponse)
							{
								return response;
							}
						}
						syntax_error(program, current, "low memory");
						return NULL;
					}
				}
				else
				{
					syntax_error(program, a, "class without key");
					return NULL;
				}
				continue;
			}
			else
			if (symbol_check_type(a, SYMBOL_FUNCTION))
			{
				symbol_t *ak;
				ak = syntax_extract_with(a, SYMBOL_KEY);
				if (ak)
				{
					if (syntax_strcmp(current, ak) == 0)
					{
						response_t *response = response_create();
						if (response)
						{
							iresponse_t *iresponse;
							iresponse = response_rpush(response, a);
							if (iresponse)
							{
								return response;
							}
						}
						syntax_error(program, current, "low memory");
						return NULL;
					}
				}
				else
				{
					syntax_error(program, a, "function without key");
					return NULL;
				}
				continue;
			}
			else
			if (symbol_check_type(a, SYMBOL_VAR))
			{
				symbol_t *ak;
				ak = syntax_extract_with(a, SYMBOL_KEY);
				if (ak)
				{
					if (syntax_strcmp(current, ak) == 0)
					{
						response_t *response = response_create();
						if (response)
						{
							iresponse_t *iresponse;
							iresponse = response_rpush(response, a);
							if (iresponse)
							{
								return response;
							}
						}
						syntax_error(program, current, "low memory");
						return NULL;
					}
				}
				else
				{
					syntax_error(program, a, "var without key");
					return NULL;
				}
				continue;
			}
			else
			if (symbol_check_type(a, SYMBOL_ENUM))
			{
				symbol_t *ak;
				ak = syntax_extract_with(a, SYMBOL_KEY);
				if (ak)
				{
					if (syntax_strcmp(current, ak) == 0)
					{
						response_t *response = response_create();
						if (response)
						{
							iresponse_t *iresponse;
							iresponse = response_rpush(response, a);
							if (iresponse)
							{
								return response;
							}
						}
						syntax_error(program, current, "low memory");
						return NULL;
					}
				}
				else
				{
					syntax_error(program, a, "enum without key");
					return NULL;
				}
				continue;
			}
			else
			if (symbol_check_type(a, SYMBOL_PROPERTY))
			{
				symbol_t *ak;
				ak = syntax_extract_with(a, SYMBOL_KEY);
				if (ak)
				{
					if (syntax_strcmp(current, ak) == 0)
					{
						response_t *response = response_create();
						if (response)
						{
							iresponse_t *iresponse;
							iresponse = response_rpush(response, a);
							if (iresponse)
							{
								return response;
							}
						}
						syntax_error(program, current, "low memory");
						return NULL;
					}
				}
				else
				{
					syntax_error(program, a, "property without key");
					return NULL;
				}
				continue;
			}
			else
			if (symbol_check_type(a, SYMBOL_HERITAGES))
			{
				symbol_t *b;
				for (b = a->begin;b != a->end;b = b->next)
				{
					if (symbol_check_type(b, SYMBOL_HERITAGE))
					{
						symbol_t *bk;
						bk = syntax_extract_with(b, SYMBOL_KEY);
						if (bk)
						{
							if (syntax_strcmp(current, bk) == 0)
							{
								response_t *response = response_create();
								if (response)
								{
									iresponse_t *iresponse;
									iresponse = response_rpush(response, b);
									if (iresponse)
									{
										return response;
									}
								}
								syntax_error(program, current, "low memory");
								return NULL;
							}
						}
						else
						{
							syntax_error(program, b, "heritage without key");
							return NULL;
						}
					}
				}
				continue;
			}
			else
			if (symbol_check_type(a, SYMBOL_GENERICS))
			{
				symbol_t *b;
				for (b = a->begin;b != a->end;b = b->next)
				{
					if (symbol_check_type(b, SYMBOL_GENERIC))
					{
						symbol_t *bk;
						bk = syntax_extract_with(b, SYMBOL_KEY);
						if (bk)
						{
							if (syntax_strcmp(current, bk) == 0)
							{
								response_t *response = response_create();
								if (response)
								{
									iresponse_t *iresponse;
									iresponse = response_rpush(response, b);
									if (iresponse)
									{
										return response;
									}
								}
								syntax_error(program, current, "low memory");
								return NULL;
							}
						}
						else
						{
							syntax_error(program, b, "heritage without key");
							return NULL;
						}
					}
				}
				continue;
			}
			else
			if (symbol_check_type(a, SYMBOL_PARAMETERS))
			{
				symbol_t *b;
				for (b = a->begin;b != a->end;b = b->next)
				{
					if (symbol_check_type(b, SYMBOL_PARAMETER))
					{
						symbol_t *bk;
						bk = syntax_extract_with(b, SYMBOL_KEY);
						if (bk)
						{
							if (syntax_strcmp(current, bk) == 0)
							{
								response_t *response = response_create();
								if (response)
								{
									iresponse_t *iresponse;
									iresponse = response_rpush(response, a);
									if (iresponse)
									{
										return response;
									}
								}
								syntax_error(program, current, "low memory");
								return NULL;
							}
						}
						else
						{
							syntax_error(program, b, "parameter without key");
							return NULL;
						}
					}
				}
				continue;
			}
		}

		base = base->parent;
	}

	syntax_error(program, current, "not found");
	return NULL;
}

static response_t *
syntax_number(program_t *program, symbol_t *current)
{
	response_t *response = response_create();
	if (response)
	{
		iresponse_t *iresponse;
		iresponse = response_rpush(response, current);
		if (iresponse)
		{
			return response;
		}
	}
	syntax_error(program, current, "low memory");
	return NULL;
}

static response_t *
syntax_string(program_t *program, symbol_t *current)
{
	response_t *response = response_create();
	if (response)
	{
		iresponse_t *iresponse;
		iresponse = response_rpush(response, current);
		if (iresponse)
		{
			return response;
		}
	}
	syntax_error(program, current, "low memory");
	return NULL;
}

static response_t *
syntax_char(program_t *program, symbol_t *current)
{
	response_t *response = response_create();
	if (response)
	{
		iresponse_t *iresponse;
		iresponse = response_rpush(response, current);
		if (iresponse)
		{
			return response;
		}
	}
	syntax_error(program, current, "low memory");
	return NULL;
}

static response_t *
syntax_null(program_t *program, symbol_t *current)
{
	response_t *response = response_create();
	if (response)
	{
		iresponse_t *iresponse;
		iresponse = response_rpush(response, current);
		if (iresponse)
		{
			return response;
		}
	}
	syntax_error(program, current, "low memory");
	return NULL;
}

static response_t *
syntax_true(program_t *program, symbol_t *current)
{
	response_t *response = response_create();
	if (response)
	{
		iresponse_t *iresponse;
		iresponse = response_rpush(response, current);
		if (iresponse)
		{
			return response;
		}
	}
	syntax_error(program, current, "low memory");
	return NULL;
}

static response_t *
syntax_false(program_t *program, symbol_t *current)
{
	response_t *response = response_create();
	if (response)
	{
		iresponse_t *iresponse;
		iresponse = response_rpush(response, current);
		if (iresponse)
		{
			return response;
		}
	}
	syntax_error(program, current, "low memory");
	return NULL;
}

static response_t *
syntax_array(program_t *program, symbol_t *current)
{
	response_t *response = response_create();
	if (response)
	{
		iresponse_t *iresponse;
		iresponse = response_rpush(response, current);
		if (iresponse)
		{
			return response;
		}
	}
	syntax_error(program, current, "low memory");
	return NULL;
}

static response_t *
syntax_lambda(program_t *program, symbol_t *current)
{
	response_t *response = response_create();
	if (response)
	{
		iresponse_t *iresponse;
		iresponse = response_rpush(response, current);
		if (iresponse)
		{
			return response;
		}
	}
	syntax_error(program, current, "low memory");
	return NULL;
}

static response_t *
syntax_object(program_t *program, symbol_t *current)
{
	response_t *response = response_create();
	if (response)
	{
		iresponse_t *iresponse;
		iresponse = response_rpush(response, current);
		if (iresponse)
		{
			return response;
		}
	}
	syntax_error(program, current, "low memory");
	return NULL;
}

static response_t *
syntax_parenthesis(program_t *program, symbol_t *current)
{
	response_t *response = response_create();
	if (response)
	{
		iresponse_t *iresponse;
		iresponse = response_rpush(response, current);
		if (iresponse)
		{
			return response;
		}
	}
	syntax_error(program, current, "low memory");
	return NULL;
}

static response_t *
syntax_primary(program_t *program, symbol_t *current)
{
	if (symbol_check_type(current, SYMBOL_ID))
	{
		return syntax_id(program, current);
	}
	else
	if (symbol_check_type(current, SYMBOL_NUMBER))
	{
		return syntax_number(program, current);
	}
	else
	if (symbol_check_type(current, SYMBOL_STRING))
	{
		return syntax_string(program, current);
	}
	else
	if (symbol_check_type(current, SYMBOL_CHAR))
	{
		return syntax_char(program, current);
	}
	else
	if (symbol_check_type(current, SYMBOL_NULL))
	{
		return syntax_null(program, current);
	}
	else
	if (symbol_check_type(current, SYMBOL_TRUE))
	{
		return syntax_true(program, current);
	}
	else
	if (symbol_check_type(current, SYMBOL_FALSE))
	{
		return syntax_false(program, current);
	}
	else
	if (symbol_check_type(current, SYMBOL_ARRAY))
	{
		return syntax_array(program, current);
	}
	else
	if (symbol_check_type(current, SYMBOL_OBJECT))
	{
		return syntax_object(program, current);
	}
	else
	if (symbol_check_type(current, SYMBOL_LAMBDA))
	{
		return syntax_lambda(program, current);
	}
	else
	if (symbol_check_type(current, SYMBOL_PARENTHESIS))
	{
		return syntax_parenthesis(program, current);
	}
	else
	{
		syntax_error(program, current, "not a primary");
		return NULL;
	}
}

static int32_t
syntax_subset_of(program_t *program, symbol_t *a, symbol_t *b)
{
	if (a == b)
	{
		return 1;
	}

	if (symbol_check_type(a, SYMBOL_CLASS))
	{
		symbol_t *hs;
		hs = syntax_only_with(a, SYMBOL_HERITAGES);
		if (hs)
		{
			symbol_t *h;
			for (h = hs->begin;h != hs->end;h = h->next)
			{
				if (symbol_check_type(h, SYMBOL_HERITAGE))
				{
					symbol_t *ht;
					ht = syntax_extract_with(h, SYMBOL_TYPE);
					if (ht)
					{
						response_t *r;
						r = syntax_expression(program, ht);
						if (r)
						{
							iresponse_t *ir;
							for (ir = r->begin;ir != r->end;ir = ir->next)
							{
								int32_t result;
								result = syntax_subset_of(program, (symbol_t *)ir->value, b);
								if (result == -1)
								{
									return -1;
								}
								else
								if (result == 1)
								{
									return 1;
								}
							}
						}
						else
						if (result == 0)
						{
							syntax_error(program, ht, "reference not found");
							return -1;
						}
						else
						{
							
						}
					}
				}
			}
		}
	}

	return 0;
}

static int32_t
syntax_asgs(program_t *program, symbol_t *as, symbol_t *gs)
{
	uint64_t a_cnt = 0;
	int32_t value_used = 0;
	list_t *g_list = list_create();
	symbol_t *a;
	for (a = as->begin;a != as->end;a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_ARGUMENT))
		{
			a_cnt += 1;
			symbol_t *av;
			av = syntax_extract_with(a, SYMBOL_VALUE);
			if (av)
			{
				value_used = 1;
				symbol_t *ak;
				ak = syntax_extract_with(a, SYMBOL_KEY);
				if (ak)
				{
					uint64_t g_cnt = 0;
					symbol_t *g;
					for (g = gs->begin;g != gs->end;g = g->next)
					{
						if (symbol_check_type(g, SYMBOL_GENERIC))
						{
							g_cnt += 1;

							symbol_t *gk;
							gk = syntax_extract_with(g, SYMBOL_KEY);
							if (gk)
							{
								if (syntax_strcmp(ak, gk) == 0)
								{
									symbol_t *ar;
									int32_t result;
									result = syntax_expression(program, av, ar);
									if (result == -1)
									{
										return -1;
									}
									else
									if (result == 0)
									{
										syntax_error(program, ak, "reference not found");
										return -1;
									}
									else
									{
										symbol_t *gt;
										gt = syntax_extract_with(g, SYMBOL_TYPE);
										if (gt)
										{
											symbol_t *gr;
											int32_t result;
											result = syntax_expression(program, gt, gr);
											if (result == -1)
											{
												return -1;
											}
											else
											if (result == 0)
											{
												syntax_error(program, gt, "reference not found");
												return -1;
											}
											else
											{
												int32_t result;
												result = syntax_subset_of(program, ar, gr);
												if (result == -1)
												{
													return -1;
												}
												else
												if (result == 0)
												{
													return 0;
												}

												list_rpush(g_list, g_cnt);
											}
										}
										else
										{
											break;
										}
									}
								}
							}
						}
					}
				}
			}
			else
			{
				if (value_used == 1)
				{
					syntax_error(program, a, "value already has been used");
					return -1;
				}
				symbol_t *ak;
				ak = syntax_extract_with(a, SYMBOL_KEY);
				if (ak)
				{
					symbol_t *ar;
					int32_t result;
					result = syntax_expression(program, ak, ar);
					if (result == -1)
					{
						return -1;
					}
					else
					if (result == 0)
					{
						syntax_error(program, ak, "reference not found");
						return -1;
					}
					else
					{
						uint64_t g_cnt = 0;
						symbol_t *g;
						for (g = gs->begin;g != gs->end;g = g->next)
						{
							if (symbol_check_type(g, SYMBOL_GENERIC))
							{
								g_cnt += 1;
								if (g_cnt < a_cnt)
								{
									continue;
								}

								symbol_t *gt;
								gt = syntax_extract_with(g, SYMBOL_TYPE);
								if (gt)
								{
									symbol_t *gr;
									int32_t result;
									result = syntax_expression(program, gt, gr);
									if (result == -1)
									{
										return -1;
									}
									else
									if (result == 0)
									{
										syntax_error(program, gt, "reference not found");
										return -1;
									}
									else
									{
										int32_t result;
										result = syntax_subset_of(program, ar, gr);
										if (result == -1)
										{
											return -1;
										}
										else
										if (result == 0)
										{
											return 0;
										}
									}
								}
								else
								{
									break;
								}
							}
						}
					}
				}
				else
				{
					syntax_error(program, a, "argument without key");
					return -1;
				}
			}
		}
	}

	if (value_used > 0)
	{
		uint64_t g_cnt = 0;
		symbol_t *g;
		for (g = gs->begin;g != gs->end;g = g->next)
		{
			g_cnt += 1;

			int32_t item_found = 0;
			ilist_t *c;
			for (c = g_list->begin;c != g_list->end;c = c->next)
			{
				if (c->value == g_cnt)
				{
					item_found = 1;
					break;
				}
			}
			if (item_found == 0)
			{
				symbol_t *gv;
				gv = syntax_only_with(g, SYMBOL_VALUE);
				if (!gv)
				{
					return 0;
				}
			}
		}
	}
	
	list_destroy(g_list);
	
	return 1;
}

static int32_t
syntax_composite(program_t *program, symbol_t *current)
{
	symbol_t *key;
	key = syntax_extract_with(current, SYMBOL_KEY);
	if (key)
	{
		response_t response2;
		int32_t result;
		result = syntax_expression(program, current, &response2);
		if (result == -1)
		{
			return -1;
		}
		else
		if (result == 0)
		{
			syntax_error(program, current, "composite base not found");
			return -1;
		}
		else
		{
			symbol_t *as;
			as = syntax_only_with(current, SYMBOL_ARGUMENTS);
			if (as)
			{
				symbol_t *gs;
				gs = syntax_only_with(&response2, SYMBOL_GENERICS);
				if (gs)
				{
					result = syntax_asgs(program, as, gs);
					if (result == -1)
					{
						return -1;
					}
					else 
					if (result == 0)
					{
						return 0;
					}
					else
					{
						*response = response2;
						return 1;
					}
				}
				else
				{
					syntax_error(program, &response2, "generic not found");
					return -1;
				}
			}
			else
			{
				syntax_error(program, current, "composite without arguments");
				return -1;
			}
		}
	}
	return 0;
}
