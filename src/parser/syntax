#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>

#include "../types/types.h"
#include "../container/list.h"
#include "../token/position.h"
#include "../token/token.h"
#include "../program.h"
#include "../scanner/file.h"
#include "../scanner/scanner.h"
#include "../ast/node.h"
#include "../utils/utils.h"
#include "../utils/path.h"
#include "parser.h"
#include "error.h"
#include "response.h"
#include "syntax.h"

#define max(a, b) a > b ? a : b

static error_t *
syntax_error(program_t *program, node_t *node, const char *format, ...)
{
	char *message;
	message = malloc(1024);
	if (!message)
	{
		return NULL;
	}

	va_list arg;
	if (format)
	{
		va_start(arg, format);
		vsprintf(message, format, arg);
		va_end(arg);
	}

	error_t *error;
	error = error_create(node->position, message);
	if (!error)
	{
		return NULL;
	}

	if (response_rpush(program->errors, error))
	{
		return NULL;
	}

	return error;
}




static int32_t
syntax_func(program_t *program, node_t *node);

static int32_t
syntax_parameter(program_t *program, node_t *node);

static int32_t
syntax_generic(program_t *program, node_t *node);

static int32_t
syntax_body(program_t *program, node_t *node);

static int32_t
syntax_var(program_t *program, node_t *node);


static int32_t
syntax_expression(program_t *program, node_t *node, response_t *response);

static int32_t
syntax_prefix(program_t *program, node_t *node, response_t *response);

static int32_t
syntax_postfix(program_t *program, node_t *node, response_t *response);

static node_t *
syntax_separate(node_t *node, int32_t kind)
{
	node_t *n1;
	for (n1 = node->begin;n1 != node->end;n1 = n1->next)
	{
		if (n1->kind == kind)
		{
			return n1;
		}
	}
	return NULL;
}

static int32_t
syntax_idcmp(node_t *n1, node_t *n2)
{
	node_basic_t *nb1 = (node_basic_t *)n1->value;
	node_basic_t *nb2 = (node_basic_t *)n2->value;

	//printf("%s %s\n", nb1->value, nb2->value);

	return strcmp(nb1->value, nb2->value);
}

static int32_t
syntax_idstrcmp(node_t *n1, char *name)
{
	node_basic_t *nb1 = (node_basic_t *)n1->value;
	return strcmp(nb1->value, name);
}



static int32_t
syntax_id(program_t *program, node_t *node, response_t *response)
{
    node_t *parent = node->parent;
    node_t *subroot = parent->end;
    region_start:
    if (parent == NULL)
    {
        node_t *n1;
        for (n1 = parent->begin;n1 != parent->end;n1 = n1->next)
        {
            if (n1->kind == NODE_KIND_CLASS)
            {
                node_class_t *c1 = (node_class_t *)n1->value;
                if (syntax_idcmp(node, c1->key) == 0)
                {
                    iresponse_t *r1 = response_rpush(response, n1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "unable to allocate memory\n");
                        return -1;
                    }
                }
                continue;
            }
            else
            if (n1->kind == NODE_KIND_FUNC)
            {
                node_func_t *f1 = (node_func_t *)n1->value;
                if (syntax_idcmp(node, f1->key) == 0)
                {
                    iresponse_t *r1 = response_rpush(response, n1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "unable to allocate memory\n");
                        return -1;
                    }
                }
                continue;
            }
            else
            if (n1->kind == NODE_KIND_PROPERTY)
            {
                node_property_t *p1 = (node_property_t *)n1->value;
                if (syntax_idcmp(node, p1->key) == 0)
                {
                    iresponse_t *r1 = response_rpush(response, n1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "unable to allocate memory\n");
                        return -1;
                    }
                }
                continue;
            }
            else
            if (n1->kind == NODE_KIND_ENUM)
            {
                node_enum_t *e1 = (node_enum_t *)n1->value;
                if (syntax_idcmp(node, e1->key) == 0)
                {
                    iresponse_t *r1 = response_rpush(response, n1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "unable to allocate memory\n");
                        return -1;
                    }
                }
                continue;
            }
            else
            if (n1->kind == NODE_KIND_PARAMETERS)
            {
                node_block_t *b1 = (node_block_t *)n1->value;
                if (b1 != NULL)
                {
                    iresponse_t *a1;
                    for (a1 = b1->list->begin;a1 != b1->list->end;a1 = a1->next)
                    {
                        node_t *pn1 = (node_t *)a1->value;
                        if (pn1->kind == NODE_KIND_PARAMETER)
                        {
                            node_parameter_t *p1 = (node_parameter_t *)pn1->value;
                            if (syntax_idcmp(node, p1->key) == 0)
                            {
                                iresponse_t *r1 = response_rpush(response, pn1);
                                if (r1 == NULL)
                                {
                                    fprintf(stderr, "unable to allocate memory\n");
                                    return -1;
                                }
                            }
                        }
                    }
                }
                continue;
            }
            else
            if (n1->kind == NODE_KIND_GENERICS)
            {
                node_block_t *b1 = (node_block_t *)n1->value;
                if (b1 != NULL)
                {
                    iresponse_t *a1;
                    for (a1 = b1->list->begin;a1 != b1->list->end;a1 = a1->next)
                    {
                        node_t *pn1 = (node_t *)a1->value;
                        if (pn1->kind == NODE_KIND_GENERIC)
                        {
                            node_generic_t *p1 = (node_generic_t *)pn1->value;
                            if (syntax_idcmp(node, p1->key) == 0)
                            {
                                iresponse_t *r1 = response_rpush(response, pn1);
                                if (r1 == NULL)
                                {
                                    fprintf(stderr, "unable to allocate memory\n");
                                    return -1;
                                }
                            }
                        }
                    }
                }
                continue;
            }
            else
            if (n1->kind == NODE_KIND_HERITAGES)
            {
                node_block_t *b1 = (node_block_t *)n1->value;
                if (b1 != NULL)
                {
                    iresponse_t *a1;
                    for (a1 = b1->list->begin;a1 != b1->list->end;a1 = a1->next)
                    {
                        node_t *pn1 = (node_t *)a1->value;
                        if (pn1->kind == NODE_KIND_HERITAGE)
                        {
                            node_heritage_t *p1 = (node_heritage_t *)pn1->value;
                            if (syntax_idcmp(node, p1->key) == 0)
                            {
                                iresponse_t *r1 = response_rpush(response, pn1);
                                if (r1 == NULL)
                                {
                                    fprintf(stderr, "unable to allocate memory\n");
                                    return -1;
                                }
                            }
                        }
                    }
                }
                continue;
            }
            
            if (parent->kind != NODE_KIND_MODULE)
            {
                if (n1->id == subroot)
                {
                    break;
                }
            }

            if (n1->kind == NODE_KIND_VAR)
            {
                node_var_t *v1 = (node_var_t *)n1->value;
                if (syntax_idcmp(node, v1->key) == 0)
                {
                    iresponse_t *r1 = response_rpush(response, n1);
                    if (r1 == NULL)
                    {
                        fprintf(stderr, "unable to allocate memory\n");
                        return -1;
                    }
                }
                continue;
            }
            else
            if (n1->kind == NODE_KIND_IF)
            {
                node_if_t *i1 = (node_if_t *)n1->value;
                if (i1->key != NULL)
                {
                    if (syntax_idcmp(node, i1->key) == 0)
                    {
                        iresponse_t *r1 = response_rpush(response, n1);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "unable to allocate memory\n");
                            return -1;
                        }
                    }
                }
                continue;
            }
            else
            if (n1->kind == NODE_KIND_FOR)
            {
                node_for_t *f1 = (node_for_t *)n1->value;
                if (f1->key != NULL)
                {
                    if (syntax_idcmp(node, f1->key) == 0)
                    {
                        iresponse_t *r1 = response_rpush(response, n1);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "unable to allocate memory\n");
                            return -1;
                        }
                    }
                }
                continue;
            }
            else
            if (n1->kind == NODE_KIND_FORIN)
            {
                node_for_t *f1 = (node_for_t *)n1->value;
                if (f1->key != NULL)
                {
                    if (syntax_idcmp(node, f1->key) == 0)
                    {
                        iresponse_t *r1 = response_rpush(response, n1);
                        if (r1 == NULL)
                        {
                            fprintf(stderr, "unable to allocate memory\n");
                            return -1;
                        }
                    }
                }
                continue;
            }
        }
    }

    if(parent->parent != NULL)
    {
        subroot = parent;
        parent = parent->parent;
        goto region_start;
    }
	return 1;
}

static int32_t
syntax_number(program_t *program, node_t *node, response_t *response)
{
    iresponse_t *r1 = response_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }
	return 1;
}

static int32_t
syntax_string(program_t *program, node_t *node, response_t *response)
{
	iresponse_t *r1 = response_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }
	return 1;
}

static int32_t
syntax_char(program_t *program, node_t *node, response_t *response)
{
	iresponse_t *r1 = response_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }
	return 1;
}

static int32_t
syntax_null(program_t *program, node_t *node, response_t *response)
{
	iresponse_t *r1 = response_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }
	return 1;
}

static int32_t
syntax_true(program_t *program, node_t *node, response_t *response)
{
	iresponse_t *r1 = response_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }
	return 1;
}

static int32_t
syntax_false(program_t *program, node_t *node, response_t *response)
{
	iresponse_t *r1 = response_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }
	return 1;
}

static int32_t
syntax_array(program_t *program, node_t *node, response_t *response)
{
    iresponse_t *r1 = response_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }
	return 1;
}

static int32_t
syntax_object(program_t *program, node_t *node, response_t *response)
{
	iresponse_t *r1 = response_rpush(response, node);
    if (r1 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }
	return 1;
}

static int32_t
syntax_parenthesis(program_t *program, node_t *node, response_t *response)
{
	node_unary_t *unary = (node_unary_t *)node->value;
    if (unary != NULL)
    {
        return syntax_expression(program, unary->right, response);
    }
    return 0;
}

static int32_t
syntax_lambda(program_t *program, node_t *node, response_t *response)
{
    node_lambda_t *lambda = (node_lambda_t *)node->value;
    
    if (lambda->parameters != NULL)
    {
        node_block_t *block = (node_block_t *)lambda->parameters->value;
        iresponse_t *a;
        for (a = block->list->begin; a != block->list->end; a = a->next)
        {
            node_t *parameter = (node_t *)a->value;

            response_t *response2 = response_create();
            if (response2 == NULL)
            {
                fprintf(stderr, "unable to allocate memory\n");
                return -1;
            }
            int32_t result = syntax_parameter(program, parameter, response2);
            if (result == -1)
            {
                return -1;
            }
            else
            if (result == 0)
            {
                syntax_error(program, node, "without response");
                return -1;
            }
            else
            {
                node_t *bp1 == NULL;
                iresponse_t *b1;
                for (b1 = response2->begin; b1 != response2->end; b1 = b1->next)
                {
                    node_t *bn1 = (node_t *)b1->value;
                    if (bp1 != NULL)
                    {
                        if (bn1->id == bp1->id)
                        {
                            syntax_error(program, node, "multiple responses");
                            return -1;
                        }
                    }
                    bp1 = bn1;
                }
            }
            response_destroy(response2);
        }
    }

	if (lambda->body)
    {
        node_t *body = lambda->body;
        if(body->kind == NODE_KIND_BODY)
        {
            response_t *response2 = response_create();
            if (response2 == NULL)
            {
                fprintf(stderr, "unable to allocate memory\n");
                return -1;
            }

            int32_t result = syntax_body(program, body, response2);
            if (result == -1)
            {
                return -1;
            }
            else
            if (result == 0)
            {
                syntax_error(program, node, "without response");
                return -1;
            }
            else
            {
                node_t *bp1 == NULL;
                iresponse_t *b1;
                for (b1 = response2->begin; b1 != response2->end; b1 = b1->next)
                {
                    node_t *bn1 = (node_t *)b1->value;
                    if (bp1 != NULL)
                    {
                        if (bn1->id == bp1->id)
                        {
                            syntax_error(program, node, "multiple responses");
                            return -1;
                        }
                    }
                    bp1 = bn1;
                }
            }
            response_destroy(response2);
        }
        else
        {
            response_t *response2 = response_create();
            if (response2 == NULL)
            {
                fprintf(stderr, "unable to allocate memory\n");
                return -1;
            }

            int32_t result = syntax_expression(program, body, response2);
             if (result == -1)
            {
                return -1;
            }
            else
            if (result == 0)
            {
                syntax_error(program, node, "without response");
                return -1;
            }
            else
            {
                node_t *bp1 == NULL;
                iresponse_t *b1;
                for (b1 = response2->begin; b1 != response2->end; b1 = b1->next)
                {
                    node_t *bn1 = (node_t *)b1->value;
                    if (bp1 != NULL)
                    {
                        if (bn1->id == bp1->id)
                        {
                            syntax_error(program, node, "multiple responses");
                            return -1;
                        }
                    }
                    bp1 = bn1;
                }
            }
            response_destroy(response2);
        }
    }
    
    return 1;
}

static int32_t
syntax_primary(program_t *program, node_t *node, response_t *response)
{
	if (node->kind == NODE_KIND_ID)
	{
		return syntax_id(program, node, response);
	}
	else
	if (node->kind == NODE_KIND_NUMBER)
	{
		return syntax_number(program, node, response);
	}
	else
	if (node->kind == NODE_KIND_STRING)
	{
		return syntax_string(program, node, response);
	}
	else
	if (node->kind == NODE_KIND_CHAR)
	{
		return syntax_char(program, node, response);
	}
	else
	if (node->kind == NODE_KIND_NULL)
	{
		return syntax_null(program, node, response);
	}
	else
	if (node->kind == NODE_KIND_TRUE)
	{
		return syntax_true(program, node, response);
	}
	else
	if (node->kind == NODE_KIND_FALSE)
	{
		return syntax_false(program, node, response);
	}
	else
	if (node->kind == NODE_KIND_ARRAY)
	{
		return syntax_array(program, node, response);
	}
	else
	if (node->kind == NODE_KIND_OBJECT)
	{
		return syntax_object(program, node, response);
	}
	else
	if (node->kind == NODE_KIND_LAMBDA)
	{
		return syntax_lambda(program, node, response);
	}
	else
	{
		return syntax_parenthesis(program, node, response);
	}
}

static int32_t
syntax_composite(program_t *program, node_t *node, response_t *response)
{
	node_composite_t *node_composite = (node_composite_t *)node->value;

    response_t *response2 = response_create();
    if (response2 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }

    int32_t result;
    result = syntax_expression(program, node_composite->base, response2);
    if (result == -1)
    {
        return -1;
    }

    int32_t *impression = 0;

    iresponse_t *r1;
    for (r1 = response2->begin; r1 != response2->end; r1 = r1->next)
    {
        node_t *rn1 = (node_t *)r1->value;
        if (rn1->kind == NODE_KIND_CLASS)
        {
            node_class_t *nc1 = (node_class_t *)r1->value;
            node_t *ngs1 = nc1->generics;
            if (ngs1 != NULL)
            {
                int32_t r2 = syntax_match_gsas(program, ngs1, node_composite->arguments);
                if (r2 == -1)
                {
                    return -1;
                }
                else
                if (r2 == 1)
                {
                    iresponse_t *r3 = response_rpush(response, rn1);
                    if (r3 == NULL)
                    {
                        fprintf(stderr, "unable to allocate memory\n");
                        return -1;
                    }
                    impression += 1;
                }
            }
        }
        else
        if (rn1->kind == NODE_KIND_FUNC)
        {
            node_func_t *nc1 = (node_func_t *)r1->value;
            node_t *ngs1 = nc1->generics;
            if (ngs1 != NULL)
            {
                int32_t r2 = syntax_match_gsas(program, ngs1, node_composite->arguments);
                if (r2 == -1)
                {
                    return -1;
                }
                else
                if (r2 == 1)
                {
                    iresponse_t *r3 = response_rpush(response, rn1);
                    if (r3 == NULL)
                    {
                        fprintf(stderr, "unable to allocate memory\n");
                        return -1;
                    }
                    impression += 1;
                }
            }
        }
    }

    if (impression > 0)
    {
        return 1;
    }

    return 0;
}

static int32_t
syntax_call(program_t *program, node_t *node, response_t *response)
{
	node_call_t *node_call = (node_call_t *)node->value;

    response_t *response2 = response_create();
    if (response2 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }

    int32_t result;
    result = syntax_expression(program, node_call->base, response2);
    if (result == -1)
    {
        return -1;
    }

    int32_t *impression = 0;

    iresponse_t *r1;
    for (r1 = response2->begin; r1 != response2->end; r1 = r1->next)
    {
        node_t *rn1 = (node_t *)r1->value;
        if (rn1->kind == NODE_KIND_CLASS)
        {
            node_class_t *nc1 = (node_class_t *)r1->value;
            node_t *n1 = nc1->block;
            node_block_t *nb1 = (node_block_t *)n1->value;

            iresponse_t *a1;
            for (a1 = nb1->list->begin; a1 != nb1->list->end; a1 = a1->next)
            {
                node_t *an1 = (node_t *)a1->value;
                if (an1->kind == NODE_KIND_FUNC)
                {
                    node_func_t *f1 = (node_func_t *)an1->value;
                    if (syntax_idstrcmp(f1->key, "constructor") == 0)
                    {
                        node_t *nps1 = f1->parameters;
                        if (nps1 != NULL)
                        {
                            int32_t r2 = syntax_match_psds(program, nps1, node_call->arguments);
                            if (r2 == -1)
                            {
                                return -1;
                            }
                            else
                            if (r2 == 1)
                            {
                                iresponse_t *r3 = response_rpush(response, rn1);
                                if (r3 == NULL)
                                {
                                    fprintf(stderr, "unable to allocate memory\n");
                                    return -1;
                                }
                                impression += 1;
                            }
                        }
                    }
                }
            }
        }
        else
        if (rn1->kind == NODE_KIND_FUNC)
        {
            node_func_t *f1 = (node_func_t *)rn1->value;
            node_t *nps1 = f1->parameters;
            if (nps1 != NULL)
            {
                int32_t r2 = syntax_match_psds(program, nps1, node_call->arguments);
                if (r2 == -1)
                {
                    return -1;
                }
                else
                if (r2 == 1)
                {
                    iresponse_t *r3 = response_rpush(response, rn1);
                    if (r3 == NULL)
                    {
                        fprintf(stderr, "unable to allocate memory\n");
                        return -1;
                    }
                    impression += 1;
                }
            }
        }
    }

    if (impression > 0)
    {
        return 1;
    }

    return 0;

}

static int32_t
syntax_item(program_t *program, node_t *node, response_t *response)
{
	node_call_t *node_call = (node_call_t *)node->value;

    response_t *response2 = response_create();
    if (response2 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }

    int32_t result;
    result = syntax_expression(program, node_call->base, response2);
    if (result == -1)
    {
        return -1;
    }

    int32_t *impression = 0;

    iresponse_t *r1;
    for (r1 = response2->begin; r1 != response2->end; r1 = r1->next)
    {
        node_t *rn1 = (node_t *)r1->value;
        if (rn1->kind == NODE_KIND_CLASS)
        {
            node_class_t *nc1 = (node_class_t *)r1->value;
            node_t *n1 = nc1->block;
            node_block_t *nb1 = (node_block_t *)n1->value;

            iresponse_t *a1;
            for (a1 = nb1->list->begin; a1 != nb1->list->end; a1 = a1->next)
            {
                node_t *an1 = (node_t *)a1->value;
                if (an1->kind == NODE_KIND_FUNC)
                {
                    node_func_t *f1 = (node_func_t *)an1->value;
                    if (syntax_idstrcmp(f1->key, "[]") == 0)
                    {
                        node_t *nps1 = f1->parameters;
                        if (nps1 != NULL)
                        {
                            int32_t r2 = syntax_match_psds(program, nps1, node_call->arguments);
                            if (r2 == -1)
                            {
                                return -1;
                            }
                            else
                            if (r2 == 1)
                            {
                                if(f1->results != NULL)
                                {
                                    response_t *response3 = response_create();
                                    if (response3 == NULL)
                                    {
                                        fprintf(stderr, "unable to allocate memory\n");
                                        return -1;
                                    }

                                    int32_t result2;
                                    result2 = syntax_expression(program, f1->results, response3);
                                    if (result2 == -1)
                                    {
                                        return -1;
                                    }

                                    uint64_t cnt1 = 0;
                                    iresponse_t *r3;
                                    for (r3 = response3->begin; r3 != response3->end; r3 = r3->next)
                                    {
                                        node_t *rn2 = (node_t *)r3->value;

                                        iresponse_t *r4 = response_rpush(response, rn2);
                                        if (r4 == NULL)
                                        {
                                            fprintf(stderr, "unable to allocate memory\n");
                                            return -1;
                                        }
                                        impression += 1;
                                        cnt1 += 1;
                                    }
                                    if (cnt1 > 1)
                                    {
                                        syntax_error(program, node, "multiple response");
                                        return -1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        else
        if (rn1->kind == NODE_KIND_ARRAY)
        {
            syntax_error(program, node, "yet not made");
            return -1;
        }
        else
        {
            syntax_error(program, node, "unexpected, got array/class");
            return -1;
        }
    }

    if (impression > 0)
    {
        return 1;
    }

    return 0;
}

static int32_t
syntax_attribute(program_t *program, node_t *node, response_t *response)
{
    node_binary_t *node_binary = (node_binary_t *)node->value;

    response_t *response2 = response_create();
    if (response2 == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }

    int32_t result;
    result = syntax_expression(program, node_binary->left, response2);
    if (result == -1)
    {
        return -1;
    }

    int32_t *impression = 0;

    iresponse_t *r1;
    for (r1 = response2->begin; r1 != response2->end; r1 = r1->next)
    {
        node_t *rn1 = (node_t *)r1->value;
        if (rn1->kind == NODE_KIND_CLASS)
        {
            int32_t r2 = syntax_nest(program, rn1, node_binary->right, response);
            if (r2 == -1)
            {
                return -1;
            }
        }
        else
        if (rn1->kind == NODE_KIND_FUNC)
        {
            node_func_t *f1 = (node_func_t *)rn1->value;
            if (syntax_idcmp(f1->key, node_binary->right) == 0)
            {
                iresponse_t *r2 = response_rpush(response, rn1);
                if (r2 == NULL)
                {
                    fprintf(stderr, "unable to allocate memory\n");
                    return -1;
                }
                impression += 1;
            }
        }
    }

    if (impression > 0)
    {
        return 1;
    }

    return 0;
}

static int32_t
syntax_postfix(program_t *program, node_t *node, response_t *response)
{
	if (node->kind == NODE_KIND_COMPOSITE)
	{
		int32_t result;
		result = syntax_composite(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
	else
	if (node->kind == NODE_KIND_CALL)
	{
		int32_t result;
		result = syntax_call(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
	else
	if (node->kind == NODE_KIND_GET_ITEM)
	{
		int32_t result;
		result = syntax_item(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
	else
	if (node->kind == NODE_KIND_ATTRIBUTE)
	{
		int32_t result;
		result = syntax_attribute(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
	else
	{
		int32_t result;
		result = syntax_primary(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_prefix(program_t *program, node_t *node, response_t *response)
{
	if(node->kind == NODE_KIND_TILDE)
	{
		node_unary_t *node_unary = (node_unary_t *)node->value;

        int32_t result;
        result = syntax_prefix(program, scope, node_unary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else 
	if(node->kind == NODE_KIND_NOT)
	{
		node_unary_t *node_unary = (node_unary_t *)node->value;

        int32_t result;
        result = syntax_prefix(program, scope, node_unary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else 
	if(node->kind == NODE_KIND_NEG)
	{
		node_unary_t *node_unary = (node_unary_t *)node->value;

        int32_t result;
        result = syntax_prefix(program, scope, node_unary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else 
	if(node->kind == NODE_KIND_POS)
	{
		node_unary_t *node_unary = (node_unary_t *)node->value;

        int32_t result;
        result = syntax_prefix(program, scope, node_unary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else 
	if(node->kind == NODE_KIND_SIZEOF)
	{
		node_unary_t *node_unary = (node_unary_t *)node->value;

        int32_t result;
        result = syntax_prefix(program, scope, node_unary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else 
	if(node->kind == NODE_KIND_TYPEOF)
	{
        node_unary_t *node_unary = (node_unary_t *)node->value;

        int32_t result;
        result = syntax_prefix(program, scope, node_unary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else
	{
		int32_t result;
		result = syntax_postfix(program, parent, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_power(program_t *program, node_t *node, response_t *response)
{
	
	if(node->kind == NODE_KIND_POW)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_power(program, left, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_prefix(program, right, node_binary->right);
        if (result == -1)
        {
            return -1;
        }
        return 1;
	}
	else
	{
		int32_t result;
		result = syntax_prefix(program, parent, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_multiplicative(program_t *program, node_t *node, response_t *response)
{
	if(node->kind == NODE_KIND_MUL)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_multiplicative(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_power(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }
        return 1;
	}
	else 
	if(node->kind == NODE_KIND_DIV)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_multiplicative(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_power(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }
        return 1;
	}
	else 
	if(node->kind == NODE_KIND_MOD)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_multiplicative(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_power(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }
        return 1;
	}
	else 
	if(node->kind == NODE_KIND_EPI)
	{
        node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_multiplicative(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_power(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }
        return 1;
	}
	else
	{
		int32_t result;
		result = syntax_power(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_addative(program_t *program, node_t *node, response_t *response)
{
	if(node->kind == NODE_KIND_PLUS)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_addative(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_multiplicative(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }
        
        return 1;
	}
	else
	if(node->kind == NODE_KIND_MINUS)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_addative(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_multiplicative(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else
	{
		int32_t result;
		result = syntax_multiplicative(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_shifting(program_t *program, node_t *node, response_t *response)
{
	if(node->kind == NODE_KIND_SHL)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_shifting(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_addative(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else 
	if(node->kind == NODE_KIND_SHR)
	{
        node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_shifting(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_addative(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else
	{
		int32_t result;
		result = syntax_addative(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_relational(program_t *program, node_t *node, response_t *response)
{
	if(node->kind == NODE_KIND_LT)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;
        int32_t result;
        result = syntax_relational(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_shifting(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else 
	if(node->kind == NODE_KIND_GT)
	{
        node_binary_t *node_binary = (node_binary_t *)node->value;
        int32_t result;
        result = syntax_relational(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_shifting(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else 
	if(node->kind == NODE_KIND_LE)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;
        int32_t result;
        result = syntax_relational(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_shifting(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else 
	if(node->kind == NODE_KIND_GE)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_relational(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_shifting(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else
	{
		int32_t result;
		result = syntax_shifting(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_equality(program_t *program, node_t *node, response_t *response)
{
	if(node->kind == NODE_KIND_EQ)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_equality(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_relational(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else 
	if(node->kind == NODE_KIND_NEQ)
	{
        node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_equality(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_relational(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else
	{
		int32_t result;
		result = syntax_relational(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_bitwise_and(program_t *program, node_t *node, response_t *response)
{
	if (node->kind == NODE_KIND_AND)
	{
        node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_bitwise_and(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

		int32_t result;
        result = syntax_equality(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }
		
        return 1;
	}
	else
	{
		int32_t result;
		result = syntax_equality(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_bitwise_xor(program_t *program, node_t *node, response_t *response)
{
	if (node->kind == NODE_KIND_XOR)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_bitwise_xor(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_bitwise_and(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else
	{
		int32_t result;
		result = syntax_bitwise_and(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_bitwise_or(program_t *program, node_t *node, response_t *response)
{
	if (node->kind == NODE_KIND_OR)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_bitwise_or(program, left, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_bitwise_xor(program, right, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else
	{
		int32_t result;
		result = syntax_bitwise_xor(program, parent, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_logical_and(program_t *program, node_t *node, response_t *response)
{
	if (node->kind == NODE_KIND_LAND)
	{
        node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_logical_and(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_bitwise_or(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

		return 1;
	}
	else
	{
		int32_t result;
		result = syntax_bitwise_or(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_logical_or(program_t *program, node_t *node, response_t *response)
{
	if (node->kind == NODE_KIND_LOR)
	{
        node_binary_t *node_binary = (node_binary_t *)node->value;

        int32_t result;
        result = syntax_logical_or(program, scope, node_binary->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_logical_and(program, scope, node_binary->right);
        if (result == -1)
        {
            return -1;
        }

        return 1;
	}
	else
	{
		int32_t result;
		result = syntax_logical_and(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_conditional(program_t *program, node_t *node, response_t *response)
{
	if (node->kind == NODE_KIND_CONDITIONAL)
	{
		node_triple_t *node_triple = (node_triple_t *)node->value;

        int32_t result;
        result = syntax_logical_or(program, scope, node_triple->base);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_conditional(program, scope, node_triple->left);
        if (result == -1)
        {
            return -1;
        }

        int32_t result;
        result = syntax_conditional(program, scope, node_triple->right);
        if (result == -1)
        {
            return -1;
        }

		return 1;
	}
	else
	{
		int32_t result;
		result = syntax_logical_or(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_expression(program_t *program, node_t *node, response_t *response)
{
	return syntax_conditional(program, parent, node);
}

static int32_t
syntax_assign(program_t *program, node_t *node)
{
	if (node->kind == NODE_KIND_ASSIGN)
	{
        node_binary_t *node_binary = (node_binary_t *)node->value;

        if (node_binary->left != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->left);
            if (result == -1)
            {
                return -1;
            }
        }

        if (node_binary->right != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->right);
            if (result == -1)
            {
                return -1;
            }
        }
    }
	else 
	if (node->kind == NODE_KIND_ADD_ASSIGN)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        if (node_binary->left != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->left);
            if (result == -1)
            {
                return -1;
            }
        }

        if (node_binary->right != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->right);
            if (result == -1)
            {
                return -1;
            }
        }
	}
	else 
	if (node->kind == NODE_KIND_SUB_ASSIGN)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        if (node_binary->left != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->left);
            if (result == -1)
            {
                return -1;
            }
        }

        if (node_binary->right != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->right);
            if (result == -1)
            {
                return -1;
            }
        }
	}
	else 
	if (node->kind == NODE_KIND_DIV_ASSIGN)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        if (node_binary->left != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->left);
            if (result == -1)
            {
                return -1;
            }
        }

        if (node_binary->right != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->right);
            if (result == -1)
            {
                return -1;
            }
        }
	}
	else 
	if (node->kind == NODE_KIND_MUL_ASSIGN)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        if (node_binary->left != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->left);
            if (result == -1)
            {
                return -1;
            }
        }

        if (node_binary->right != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->right);
            if (result == -1)
            {
                return -1;
            }
        }
	}
	else 
	if (node->kind == NODE_KIND_MOD_ASSIGN)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        if (node_binary->left != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->left);
            if (result == -1)
            {
                return -1;
            }
        }

        if (node_binary->right != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->right);
            if (result == -1)
            {
                return -1;
            }
        }
	}
	else 
	if (node->kind == NODE_KIND_AND_ASSIGN)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        if (node_binary->left != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->left);
            if (result == -1)
            {
                return -1;
            }
        }

        if (node_binary->right != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->right);
            if (result == -1)
            {
                return -1;
            }
        }
	}
	else 
	if (node->kind == NODE_KIND_OR_ASSIGN)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        if (node_binary->left != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->left);
            if (result == -1)
            {
                return -1;
            }
        }

        if (node_binary->right != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->right);
            if (result == -1)
            {
                return -1;
            }
        }
	}
	else 
	if (node->kind == NODE_KIND_SHL_ASSIGN)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        if (node_binary->left != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->left);
            if (result == -1)
            {
                return -1;
            }
        }

        if (node_binary->right != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->right);
            if (result == -1)
            {
                return -1;
            }
        }
	}
	else 
	if (node->kind == NODE_KIND_SHR_ASSIGN)
	{
		node_binary_t *node_binary = (node_binary_t *)node->value;

        if (node_binary->left != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->left);
            if (result == -1)
            {
                return -1;
            }
        }

        if (node_binary->right != NULL)
        {
            int32_t result;
            result = syntax_expression(program, scope, node_binary->right);
            if (result == -1)
            {
                return -1;
            }
        }
	}
	else
	{
		int32_t result;
		result = syntax_expression(program, scope, node);
		if (result == -1)
		{
			return -1;
		}
		return 1;
	}
}

static int32_t
syntax_if(program_t *program, node_t *node)
{
	node_if_t *node_if = (node_if_t *)node->value;

	if (node_if->key)
	{
        int32_t result;
		result = syntax_id(program, scope, node_if->key);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_if->condition)
	{
        int32_t result;
		result = syntax_expression(program, scope, node_if->condition);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_if->then_body)
	{
        int32_t result;
		result = syntax_body(program, scope, node_if->then_body);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_if->else_body)
	{
        int32_t result;
		if(node_if->else_body->kind == NODE_KIND_IF)
		{
			result = syntax_if(program, scope, node_if->else_body);
		} 
		else 
		{
			result = syntax_body(program, scope, node_if->else_body);
		}

		if (result == -1)
        {
			return -1;
		}
	}

	return 1;
}

static int32_t
syntax_catch(program_t *program, node_t *node)
{
	node_catch_t *node_catch = (node_catch_t *)node->value;

	if (node_catch->parameters)
	{
		iresponse_t *a;
		for (a = node_catch->parameters->begin; a != node_catch->parameters->end; a = a->next)
		{
			node_t *parameter = (node_t *)a->value;
            int32_t result;
			result = syntax_parameter(program, scope, parameter);
			if (result == -1)
			{
				return -1;
			}
		}
	}

	if (node_catch->body)
	{
        int32_t result;
		result = syntax_body(program, scope, node_catch->body);
		if (result == -1)
		{
			return -1;
		}
	}

	return 1;
}

static int32_t
syntax_try(program_t *program, node_t *node)
{
	node_try_t *node_try = (node_try_t *)node->value;

    if (node_try->body != NULL)
    {
        int32_t result;
        result = syntax_body(program, scope, node_try->body);
        if (result == -1)
        {
            return -1;
        }
    }

	if (node_try->catchs)
	{
        response_t *catchs = node_try->catchs;
		iresponse_t *a;
		for (a = catchs->begin; a != catchs->end; a = a->next)
		{
			node_t *object = (node_t *)a->value;
            if (object != NULL)
            {
                int32_t result;
                result = syntax_catch(program, scope, object);
                if (result == -1)
                {
                    return -1;
                }
            }
		}
	}

	return 1;
}

static int32_t
syntax_for(program_t *program, node_t *node)
{
	node_for_t *node_for = (node_for_t *)node->value;

	if (node_for->key)
	{
        int32_t result;
		result = syntax_id(program, scope, node_for->key);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_for->initializer)
	{
        response_t *initializer = node_for->initializer;
        iresponse_t *a;
        for (a = initializer->begin; a != initializer->end; a = a->next)
        {
            node_t *object = (node_t *)a->value;
            if (object != NULL)
            {
                if (object->kind == NODE_KIND_VAR)
                {
                    int32_t result;
                    result = syntax_var(program, scope, object);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
                else
                {
                    int32_t result;
                    result = syntax_assign(program, scope, object);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
            }
        }
	}

	if (node_for->condition)
	{
        int32_t result;
		result = syntax_expression(program, scope, node_for->condition);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_for->incrementor)
	{
        response_t *incrementor = node_for->incrementor;
		iresponse_t *a;
		for (a = incrementor->begin; a != incrementor->end; a = a->next)
		{
			node_t *object = (node_t *)a->value;
            if (object != NULL)
            {
                int32_t result;
                result = syntax_assign(program, scope, object);
                if (result == -1)
                {
                    return -1;
                }
            }
		}
	}
	
	if (node_for->body)
	{
        int32_t result;
		result = syntax_body(program, scope, node_for->body);
		if (result == -1)
		{
			return -1;
		}
	}

	return 1;
}

static int32_t
syntax_forin(program_t *program, node_t *node)
{
	node_forin_t *node_forin = (node_forin_t *)node->value;

	
	if (node_forin->key)
	{
        int32_t result;
		result = syntax_id(program, scope, node_forin->key);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_forin->initializer)
	{
        response_t *initializer = node_forin->initializer;
		iresponse_t *a;
		for (a = initializer->begin; a != initializer->end; a = a->next)
		{
			node_t *object = (node_t *)a->value;

			if (object->kind == NODE_KIND_VAR)
			{
                int32_t result;
				result = syntax_var(program, scope, object);
				if (result == -1)
				{
					return -1;
				}
			}
			else
			{
                int32_t result;
				result = syntax_assign(program, scope, object);
				if (result == -1)
				{
					return -1;
				}
			}
		}
	}

	if (node_forin->expression)
	{
        int32_t result;
		result = syntax_expression(program, scope, node_forin->expression);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_forin->body)
	{
        int32_t result;
		result = syntax_body(program, scope, node_forin->body);
		if (result == -1)
		{
			return -1;
		}
	}

	return 1;
}

static int32_t
syntax_break(program_t *program, node_t *node)
{
	node_unary_t *node_unary = (node_unary_t *)node->value;

	int32_t result;
    result = syntax_expression(program, scope, node_unary->right);
	if (result == -1)
	{
		return -1;
	}

	return 1;
}

static int32_t
syntax_continue(program_t *program, node_t *node)
{
	node_unary_t *node_unary = (node_unary_t *)node->value;

	int32_t result;
    result = syntax_expression(program, scope, node_unary->right);
	if (result == -1)
	{
		return -1;
	}

	return 1;
}

static int32_t
syntax_return(program_t *program, node_t *node)
{
	node_unary_t *node_unary = (node_unary_t *)node->value;

	int32_t result;
    result = syntax_expression(program, scope, node_unary->right);
	if (result == -1)
	{
		return -1;
	}

	return 1;
}

static int32_t
syntax_throw(program_t *program, node_t *node)
{
	node_throw_t *node_throw = (node_throw_t *)node->value;

	if (node_throw->arguments != NULL)
	{
        response_t *arguments = node_throw->arguments;
		iresponse_t *a;
		for (a = arguments->begin; a != arguments->end; a = a->next)
		{
			node_t *argument = (node_t *)a->value;
            if (argument != NULL)
            {
                int32_t result;
                result = syntax_argument(program, scope, argument);
                if (result == -1)
                {
                    return -1;
                }
            }
		}
	}

	return 1;
}

static int32_t
syntax_statement(program_t *program, node_t *node)
{
	if (node->kind = NODE_KIND_BLOCK)
	{
        return syntax_body(program, scope, node);
    }
    else
    if (node->kind = NODE_KIND_IF)
	{
        return syntax_if(program, scope, node);
    }
    else
    if (node->kind = NODE_KIND_TRY)
	{
        return syntax_try(program, scope, node);
    }
    else
    if (node->kind = NODE_KIND_FOR)
	{
        return syntax_for(program, scope, node);
    }
    else
    if (node->kind = NODE_KIND_FORIN)
	{
        return syntax_forin(program, scope, node);
    }
    else
    if (node->kind = NODE_KIND_VAR)
	{
        return syntax_var(program, scope, node);
    }
    else
    if (node->kind = NODE_KIND_BREAK)
	{
        return syntax_break(program, scope, node);
    }
    else
    if (node->kind = NODE_KIND_CONTINUE)
	{
        return syntax_continue(program, scope, node);
    }
    else
    if (node->kind = NODE_KIND_RETURN)
	{
        return syntax_return(program, scope, node);
    }
    else
    if (node->kind = NODE_KIND_THROW)
	{
        return syntax_throw(program, scope, node);
    }
    else
    if (node->kind = NODE_KIND_FUNC)
	{
        return syntax_func(program, scope, node);
    }
    else
	{
        return syntax_assign(program, scope, node);
    }
}

static int32_t
syntax_body(program_t *program, node_t *node)
{
	node_block_t *node_block = (node_block_t *)node->value;

    if (node_block->list != NULL)
    {
        response_t *block = node_block->list;
        iresponse_t *a;
        for (a = block->begin; a != block->end; a = a->next)
        {
            node_t *object = (node_t *)a->value;
            if (object != NULL)
            {
                int32_t result;
                result = syntax_statement(program, scope, object);
                if (result == -1)
                {
                    return -1;
                }
            }
        }
    }


	return 1;
}

static int32_t
syntax_generic(program_t *program, node_t *node)
{
	node_generic_t *node_generic = (node_generic_t *)node->value;

	if (node_generic->key != NULL)
	{
		int32_t result;
		result = syntax_id(program, scope, node_generic->key);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_generic->type != NULL)
	{
		int32_t result;
		result = syntax_expression(program, scope, node_generic->type);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_generic->value != NULL)
	{
		int32_t result;
		result = syntax_expression(program, scope, node_generic->value);
		if (result == -1)
		{
			return -1;
		}
	}

	return 1;
}

static int32_t
syntax_enum(program_t *program, node_t *node)
{
	node_enum_t *node_enum = (node_enum_t *)node->value;
	
	if (node_enum->key != NULL)
	{
		int32_t result;
		result = syntax_id(program, scope, node_enum->key);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_enum->body != NULL)
	{
        response_t *body = node_enum->body;
		iresponse_t *a;
		for (a = body->begin; a != body->end; a = a->next)
		{
			node_t *member = (node_t *)a->value;
            if (member != NULL)
            {
                int32_t result;
                result = syntax_member(program, scope, member);
                if (result == -1)
                {
                    return -1;
                }
            }
		}
	}

	return 1;
}

static int32_t
syntax_property(program_t *program, node_t *node)
{
	node_property_t *node_property = (node_property_t *)node->value;

	if (node_property->key != NULL)
	{
		int32_t result;
		result = syntax_id(program, scope, node_property->key);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_property->type != NULL)
	{
		int32_t result;
		result = syntax_expression(program, scope, node_property->type);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_property->value != NULL)
	{
		int32_t result;
		result = syntax_expression(program, scope, node_property->value);
		if (result == -1)
		{
			return -1;
		}
	}

	return 1;
}

static int32_t
syntax_parameter(program_t *program, node_t *node)
{
	node_parameter_t *node_parameter = (node_parameter_t *)node->value;

	if (node_parameter->key != NULL)
	{
        int32_t result;
		result = syntax_id(program, scope, node_parameter->key);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_parameter->type != NULL)
	{
        int32_t result;
		result = syntax_expression(program, scope, node_parameter->type);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_parameter->value != NULL)
	{
		int32_t result;
		result = syntax_expression(program, scope, node_parameter->value);
		if (result == -1)
		{
			return -1;
		}
	}

	return 1;
}

static int32_t
syntax_heritage(program_t *program, node_t *node)
{
	node_heritage_t *node_heritage = (node_heritage_t *)node->value;

	if (node_heritage->key != NULL)
	{
        int32_t result
		result = syntax_id(program, scope, node_heritage->key);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_heritage->type != NULL)
	{
        int32_t result;
		result = syntax_expression(program, scope, node_heritage->type);
		if (result == -1)
		{
			return -1;
		}
	}

	return 1;
}

static int32_t
syntax_func(program_t *program, node_t *node)
{
	node_func_t *node_func = (node_func_t *)node->value;

	if (node_func->key != NULL)
	{
		int32_t result;
        result = syntax_id(program, scope, node_func->key);
        if (result == -1)
        {
            return -1;
        }
	}

	if (node_func->generics != NULL)
	{
        response_t *generics = node_func->generics;
        if (generics != NULL)
        {
            iresponse_t *a;
            for (a = generics->begin; a != generics->end; a = a->next)
            {
                node_t *generic = (node_t *)a->value;
                if (generic != NULL)
                {
                    int32_t result;
                    result = syntax_generic(program, scope, generic);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
            }
        }
	}

	if (node_func->parameters != NULL)
	{
        response_t *parameters = node_func->parameters;
        if (parameters != NULL)
        {
            for (a = parameters->begin; a != parameters->end; a = a->next)
            {
                node_t *parameter = (node_t *)a->value;
                if (parameter != NULL)
                {
                    int32_t result;
                    result = syntax_parameter(program, scope, parameter);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
            }
        }
	}

	if (node_func->body != NULL)
	{
        int32_t result;
		result = syntax_body(program, scope, node_func->body);
		if (result == -1)
		{
			return -1;
		}
	}

	return 1;
}

static int32_t
syntax_class(program_t *program, node_t *node)
{
	node_class_t *node_class = (node_class_t *)node->value;

	if (node_class->key != NULL)
	{
        int32_t result;
		result = syntax_id(program, scope, node_class->key);
		if (result == -1)
		{
			return -1;
		}
	}

	
	if (node_class->heritages != NULL)
	{
        iresponse_t *a;
		for (a = node_class->heritages->begin; a != node_class->heritages->end; a = a->next)
		{
			node_t *heritage = (node_t *)a->value;
            if (heritage != NULL)
            {
                int32_t result;
                result = syntax_heritage(program, scope, heritage);
                if (result == -1)
                {
                    return -1;
                }
            }
		}
	}

	if (node_class->generics != NULL)
	{
        iresponse_t *a;
		for (a = node_class->generics->begin; a != node_class->generics->end; a = a->next)
		{
			node_t *generic = (node_t *)a->value;
            int32_t result;
			result = syntax_generic(program, scope, generic);
			if (result == -1)
			{
				return -1;
			}
		}
	}

    if (node_class->body != NULL)
    {
        response_t *body = node_class->body;
        for (a = body->begin; a != body->end; a = a->next)
        {
            node_t *object = (node_t *)a->value;
            if (object != NULL)
            {
                if (object->kind == NODE_KIND_CLASS)
                {
                    int32_t result;
                    result = syntax_class(program, scope, object);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
                else
                if (object->kind == NODE_KIND_ENUM)
                {
                    int32_t result;
                    result = syntax_enum(program, scope, object);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
                else
                if (object->kind == NODE_KIND_PROPERTY)
                {
                    int32_t result;
                    result = syntax_property(program, scope, object);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
                else
                if (object->kind == NODE_KIND_FUNC)
                {
                    int32_t result;
                    result = syntax_func(program, scope, object);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
            }
        }
    }

	return 1;
}

static int32_t
syntax_var(program_t *program, node_t *node)
{
	node_var_t *node_var = (node_var_t *)node->value;
	
	if (node_var->key != NULL)
	{
        int32_t result;
		result = syntax_id(program, scope, node_var->key);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_var->type != NULL)
	{
        int32_t result;
		result = syntax_expression(program, scope, node_var->type);
		if (result == -1)
		{
			return -1;
		}
	}

	if (node_var->value)
	{
        int32_t result;
		result = syntax_expression(program, scope, node_var->value);
		if (result == -1)
		{
			return -1;
		}
	}

	return 1;
}

static int32_t
syntax_field(program_t *program, node_t *node)
{
	node_field_t *node_field = (node_field_t *)node->value;

	if (node_field->key)
	{
        /*
        int32_t result;
		result = syntax_expression(program, scope, node_field->key);
		if (result == -1)
		{
			return -1;
		}
        */
	}

	if (node_field->type)
	{
        /*
        int32_t result;
		result = syntax_expression(program, scope, node_field->type);
		if (result == -1)
		{
			return -1;
		}
        */
	}

	return 1;
}

static int32_t
syntax_import(program_t *program, node_t *node)
{
	node_import_t *node_import = (node_import_t *)node->value;

	if (node_import->fields)
	{
        response_t *fields = node_import->fields;
        iresponse_t *a;
        for (a = fields->begin; a != fields->end; a = a->next)
        {
            node_t *field = (node_t *)a->value;
            if (field != NULL)
            {
                int32_t result;
                result = syntax_field(program, scope, field);
                if (result == -1)
                {
                    return -1;
                }
            }
        }
	}

	return 1;
}

static int32_t
syntax_module(program_t *program, node_t *node)
{
	node_module_t node_module = (node_module_t *)node->value;
    
    if (node_module->members != NULL)
    {
        response_t *members = node_module->members;
        iresponse_t *a;
        for (a = members->begin; a != members->end; a = a->next)
        {
            node_t *member = (node_t *)a->value;
            if (member != NULL)
            {
                if (member->kind == NODE_KIND_IMPORT)
                {
                    int32_t result;
                    result = syntax_import(program, scope, member);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
                else
                if (member->kind == NODE_KIND_CLASS)
                {
                    int32_t result;
                    result = syntax_class(program, scope, member);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
                else
                if (member->kind == NODE_KIND_ENUM)
                {
                    int32_t result;
                    result = syntax_enum(program, scope, member);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
                else
                if (member->kind == NODE_KIND_FUNC)
                {
                    int32_t result;
                    result = syntax_func(program, scope, member);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
                else
                if (member->kind == NODE_KIND_VAR)
                {
                    int32_t result;
                    result = syntax_var(program, scope, member);
                    if (result == -1)
                    {
                        return -1;
                    }
                }
            }
        }
    }

	return 1;
}

int32_t
syntax_run(program_t *program, node_t *node)
{
    node_t *scope = response_create();
    if (scope == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }

    table_t *frame = table_create();
    if (frame == NULL)
    {
        fprintf(stderr, "unable to allocate memory\n");
        return -1;
    }

	int32_t result = syntax_module(program, scope, frame, node);
	if(result == -1)
	{
		return -1;
	}
	return 1;
}