#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>

#if defined(WIN32) || defined(_WIN32) || defined(__WIN32)
#include "../utils/dirent.h"
#elif defined(__arm__) || defined(__aarch64__)
#include "../utils/arm/dirent.h"
#else
#include <dirent.h>
#endif

#include "../types/types.h"
#include "../container/list.h"
#include "../token/position.h"
#include "../token/token.h"
#include "../program.h"
#include "../scanner/file.h"
#include "../scanner/scanner.h"
#include "../ast/node.h"
#include "../utils/utils.h"
#include "../utils/path.h"
#include "parser.h"
#include "error.h"
#include "symbol.h"
#include "graph.h"
#include "syntax.h"
#include "response.h"


typedef enum find_type {
	FIND_TYPE_CLASS,
	FINC_TYPE_METHOD,
	FIND_TYPE_VAR
} find_type_t;

static error_t *
syntax_error(graph_t *graph, symbol_t *current, const char *format, ...)
{
	char *message;
	message = malloc(1024);
	if (!message)
	{
		return NULL;
	}

	va_list arg;
	if (format)
	{
		va_start(arg, format);
		vsprintf(message, format, arg);
		va_end(arg);
	}

	node_t *node;
	node = current->declaration;

	error_t *error;
	error = error_create(node->position, message);
	if (!error)
	{
		return NULL;
	}

	if (list_rpush(graph->errors, (uint64_t)error))
	{
		return NULL;
	}

	return error;
}


static int32_t
syntax_symbol_contain_flag(symbol_t *reference, uint64_t flag)
{
	symbol_t *a;
	for (a = reference->begin; a != reference->end; a = a->next)
	{
		if (symbol_check_type(a, flag))
		{
			return 1;
		}
	}
	return 0;
}

static symbol_t *
syntax_only(symbol_t *target)
{
	symbol_t *a;
	for (a = target->begin;a != target->end;a = a->next)
	{
		return a;
	}
	return NULL;
}

static symbol_t *
syntax_only_with(symbol_t *target, uint64_t flag)
{
	symbol_t *a;
	for (a = target->begin;a != target->end;a = a->next)
	{
		if (symbol_check_type(a, flag))
		{
			return a;
		}
	}
	return NULL;
}

static symbol_t *
syntax_extract_with(symbol_t *target, uint64_t flag)
{
	symbol_t *a;
	a = syntax_only_with(target, flag);
	if (!!a)
	{
		return syntax_only(a);
	}
	return NULL;
}


static symbol_t *
syntax_subset_of_object(symbol_t *reference, symbol_t *target);

static symbol_t *
syntax_subset_of_array(symbol_t *reference, symbol_t *target);

static int32_t
syntax_subset_compare_string(symbol_t *reference, char *name)
{
	node_t *node_reference = reference->declaration;
	node_basic_t *node_basic_reference;
	node_basic_reference = (node_basic_t *)node_reference->value;

	return (strncmp(name, node_basic_reference->value, 
		max(strlen(node_basic_reference->value), strlen(name))) == 0);
}

static int32_t
syntax_subset_compare_id(symbol_t *reference, symbol_t *target)
{
	node_t *node_reference = reference->declaration;
	node_basic_t *node_basic_reference;
	node_basic_reference = (node_basic_t *)node_reference->value;

	node_t *node_target = target->declaration;
	node_basic_t *node_basic_target;
	node_basic_target = (node_basic_t *)node_target->value;

	//printf("%s %s\n", node_basic_target->value, node_basic_reference->value);

	return (strncmp(node_basic_target->value, node_basic_reference->value, 
		max(strlen(node_basic_reference->value), strlen(node_basic_target->value))) == 0);
}

static symbol_t *
syntax_subset_exist_in_set(symbol_t *reference, symbol_t *target)
{
	symbol_t *a;
	for (a = reference->begin;(a != reference->end); a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_ID))
		{
			int32_t result;
			result = syntax_subset_compare_id(a, target);
			if(result)
			{
				return a;
			}
		}
		else if(symbol_check_type(a, SYMBOL_OBJECT))
		{
			return syntax_subset_of_object(a, target);
		}
		else if(symbol_check_type(a, SYMBOL_ARRAY))
		{
			return syntax_subset_of_array(a, target);
		}
	}
	return NULL;
}

static symbol_t *
syntax_subset_of_object_property(symbol_t *reference, symbol_t *target)
{
	symbol_t *a;
	for(a = reference->begin; a != reference->end; a = a->next)
	{
		if(symbol_check_type(a, SYMBOL_NAME))
		{
			return syntax_subset_exist_in_set(a, target);
		}
	}
	return NULL;
}

static symbol_t *
syntax_subset_of_object(symbol_t *reference, symbol_t *target)
{
	symbol_t *a;
	for(a = reference->begin; a != reference->end; a = a->next)
	{
		if(symbol_check_type(a, SYMBOL_OBJECT_PROPERTY))
		{
			return syntax_subset_of_object_property(a, target);
		}
	}
	return NULL;
}

static symbol_t *
syntax_subset_of_array(symbol_t *reference, symbol_t *target)
{
	symbol_t *a;
	for (a = reference->begin; a != reference->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_OBJECT))
		{
			return syntax_subset_of_object(a, target);
		}
		else if (symbol_check_type(a, SYMBOL_ARRAY))
		{
			return syntax_subset_of_array(a, target);
		}
		else if (symbol_check_type(a, SYMBOL_ID))
		{
			int32_t result;
			result = syntax_subset_compare_id(a, target);
			if (result)
			{
				return a;
			}
		}
	}
	return NULL;
}

static symbol_t *
syntax_subset_exist_in_flag(symbol_t *reference, symbol_t *target, uint64_t flag)
{
	symbol_t *a;
	for (a = reference->begin;(a != reference->end); a = a->next)
	{
		if (symbol_check_type(a, flag))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_set(a, target);
			if(result)
			{
				return result;
			}
		}
	}
	return NULL;
}


static int32_t
syntax_duplicated(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *target)
{
	symbol_t *a;
	for(a = root->begin; a && (a != root->end); a = a->next)
	{	
		if (symbol_check_type(a, SYMBOL_IMPORT))
		{
			symbol_t *b;
			for(b = a->begin; b != a->end; b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_FIELD))
				{
					symbol_t *result;
					result = syntax_subset_exist_in_flag(b, target, SYMBOL_NAME);
					if(result && (result->id != target->id))
					{
						syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
							result->declaration->position.line, result->declaration->position.column);
						return 0;
					}
				}
			}
		}
		
		if (symbol_check_type(a, SYMBOL_FIELD))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_VAR))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_DEFINE))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_FUNCTION))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_TYPE))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}

		if (symbol_check_type(a, SYMBOL_IF))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}

		if (symbol_check_type(a, SYMBOL_FOR))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}

		if (symbol_check_type(a, SYMBOL_FORIN))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}

		if (symbol_check_type(a, SYMBOL_NAME))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_set(a, target);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}

		if (!symbol_check_type(root, SYMBOL_CLASS) && !symbol_check_type(root, SYMBOL_MODULE))
		{
			if (a == subroot)
			{
				break;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_CLASS))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			} 
		}

		if (symbol_check_type(a, SYMBOL_ENUM))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}

		if (symbol_check_type(a, SYMBOL_GENERIC))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			} 
		}
		
		if (symbol_check_type(a, SYMBOL_HERITAGE))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}
	
		if (symbol_check_type(a, SYMBOL_PROPERTY))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_METHOD))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if(result && (result->id != target->id))
			{
				syntax_error(graph, target, "symbol is duplicated, previous symbol in (%lld:%lld)\n", 
					result->declaration->position.line, result->declaration->position.column);
				return 0;
			}
		}
	}

	if (root->parent)
	{
		if (symbol_check_type(root, SYMBOL_BLOCK))
		{
			return syntax_duplicated(graph, root->parent, root, target);
		}
	}

	return 1;
}



static int32_t
syntax_duplicated_object(graph_t *graph, symbol_t *root, symbol_t *sub, symbol_t *current);

static int32_t
syntax_duplicated_array(graph_t *graph, symbol_t *root, symbol_t *sub, symbol_t *current);

static int32_t
syntax_duplicated_in_set(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *current)
{
	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if(symbol_check_type(a, SYMBOL_OBJECT))
		{
			return syntax_duplicated_object(graph, root, subroot, a);
		}
		else if(symbol_check_type(a, SYMBOL_ARRAY))
		{
			return syntax_duplicated_array(graph, root, subroot, a);
		}
		else if(symbol_check_type(a, SYMBOL_ID))
		{
			return syntax_duplicated(graph, root, subroot, a);
		}
	}
	return 0;
}

static int32_t
syntax_duplicated_object_property(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *current)
{
	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if(symbol_check_type(a, SYMBOL_NAME))
		{
			return syntax_duplicated_in_set(graph, root, subroot, a);
		}
	}
	return 0;
}

static int32_t
syntax_duplicated_object(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *current)
{
	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if(symbol_check_type(a, SYMBOL_OBJECT_PROPERTY))
		{
			return syntax_duplicated_object_property(graph, root, subroot, a);
		}
	}
	return 0;
}

static int32_t
syntax_duplicated_array(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin; a != current->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_OBJECT))
		{
			return syntax_duplicated_object(graph, root, subroot, a);
		}
		else if (symbol_check_type(a, SYMBOL_ARRAY))
		{
			return syntax_duplicated_array(graph, root, subroot, a);
		}
		else if (symbol_check_type(a, SYMBOL_ID))
		{
			return syntax_duplicated(graph, root, subroot, a);
		}
	}
	return 0;
}

static int32_t
syntax_duplicated_in_name(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *current)
{
	int32_t result = 1;
	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			result &= syntax_duplicated_in_set(graph, root, subroot, a);
		}
	}
	return result;
}



static symbol_t *
syntax_subset_of_reference_type(symbol_t *root, symbol_t *subroot, symbol_t *target);

static int32_t
syntax_prototype_subset_of_generic(symbol_t *reference, symbol_t *target)
{
	uint64_t ref_counter = 0;
	uint64_t reference_counter_by_value = 0;
	symbol_t *a;
	for (a = reference->begin; a != reference->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_GENERIC))
		{
			if (syntax_symbol_contain_flag(a, SYMBOL_VALUE))
			{
				reference_counter_by_value += 1;
			}
			ref_counter += 1;
		}
	}

	uint64_t tar_counter = 0;
	uint64_t target_counter_by_value = 0;

	for (a = target->begin; a != target->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_GENERIC))
		{
			if (syntax_symbol_contain_flag(a, SYMBOL_VALUE))
			{
				target_counter_by_value += 1;
			}
			tar_counter += 1;
		}
	}

	if ((ref_counter - reference_counter_by_value) == (tar_counter - target_counter_by_value))
	{
		return 1;
	}

	return 0;
}

static int32_t
syntax_prototype_subset_of_component_type(symbol_t *reference, symbol_t *target)
{
	if(symbol_check_type(reference, SYMBOL_OR))
	{
		int32_t result = 1;
		symbol_t *a;
		for (a = reference->begin; a != reference->end; a = a->next)
		{
			if (symbol_check_type(a, SYMBOL_LEFT))
			{
				result |= syntax_prototype_subset_of_component_type(a, target);
			}
			else if (symbol_check_type(a, SYMBOL_RIGHT))
			{
				result |= syntax_prototype_subset_of_component_type(a, target);
			}
		}
		return result;
	}
	else 
	if(symbol_check_type(reference, SYMBOL_AND))
	{
		int32_t result = 1;
		symbol_t *a;
		for (a = reference->begin; a != reference->end; a = a->next)
		{
			if (symbol_check_type(a, SYMBOL_LEFT))
			{
				result &= syntax_prototype_subset_of_component_type(a, target);
			}
			else if (symbol_check_type(a, SYMBOL_RIGHT))
			{
				result &= syntax_prototype_subset_of_component_type(a, target);
			}
		}
		return result;
	}
	else 
	if (symbol_check_type(reference, SYMBOL_LEFT))
	{
		if(symbol_check_type(target, SYMBOL_OR))
		{
			int32_t result = 1;
			symbol_t *a;
			for (a = target->begin; a != target->end; a = a->next)
			{
				if (symbol_check_type(a, SYMBOL_LEFT))
				{
					result |= syntax_prototype_subset_of_component_type(a, reference);
				}
				else if (symbol_check_type(a, SYMBOL_RIGHT))
				{
					result |= syntax_prototype_subset_of_component_type(a, reference);
				}
			}
			return result;
		}
		else 
		if(symbol_check_type(target, SYMBOL_AND))
		{
			int32_t result = 1;
			symbol_t *a;
			for (a = target->begin; a != target->end; a = a->next)
			{
				if (symbol_check_type(a, SYMBOL_LEFT))
				{
					result &= syntax_prototype_subset_of_component_type(a, reference);
				}
				else if (symbol_check_type(a, SYMBOL_RIGHT))
				{
					result &= syntax_prototype_subset_of_component_type(a, reference);
				}
			}
			return result;
		}
		else
		{
			symbol_t *a;
			for (a = reference->begin; a != reference->end; a = a->next)
			{
				if (!symbol_equal_type(a, target))
				{
					return 0;
				}
				if (symbol_check_type(a, SYMBOL_ID) || symbol_check_type(a, SYMBOL_NUMBER) || symbol_check_type(a, SYMBOL_CHAR))
				{
					if (!syntax_subset_compare_id(a, target))
					{
						return 0;
					}
					return 1;
				}
			}
		}
	}
	else if (symbol_check_type(reference, SYMBOL_RIGHT))
	{
		if(symbol_check_type(target, SYMBOL_OR))
		{
			int32_t result = 1;
			symbol_t *a;
			for (a = target->begin; a != target->end; a = a->next)
			{
				if (symbol_check_type(a, SYMBOL_LEFT))
				{
					result |= syntax_prototype_subset_of_component_type(a, reference);
				}
				else if (symbol_check_type(a, SYMBOL_RIGHT))
				{
					result |= syntax_prototype_subset_of_component_type(a, reference);
				}
			}
			return result;
		}
		else if(symbol_check_type(target, SYMBOL_AND))
		{
			int32_t result = 1;
			symbol_t *a;
			for (a = target->begin; a != target->end; a = a->next)
			{
				if (symbol_check_type(a, SYMBOL_LEFT))
				{
					result &= syntax_prototype_subset_of_component_type(a, reference);
				}
				else if (symbol_check_type(a, SYMBOL_RIGHT))
				{
					result &= syntax_prototype_subset_of_component_type(a, reference);
				}
			}
			return result;
		}
		else
		{
			symbol_t *a;
			for (a = reference->begin; a != reference->end; a = a->next)
			{
				if (!symbol_equal_type(a, target))
				{
					return 0;
				}
				if (symbol_check_type(a, SYMBOL_ID) || symbol_check_type(a, SYMBOL_NUMBER) || symbol_check_type(a, SYMBOL_CHAR))
				{
					if (!syntax_subset_compare_id(a, target))
					{
						return 0;
					}
					return 1;
				}
			}
		}
	}

	if (!symbol_equal_type(reference, target))
	{
		return 0;
	}

	if (symbol_check_type(reference, SYMBOL_ID) || symbol_check_type(reference, SYMBOL_NUMBER) || symbol_check_type(reference, SYMBOL_CHAR))
	{
		if (!syntax_subset_compare_id(reference, target))
		{
			return 0;
		}
		return 1;
	}

	return 0;
}

static int32_t
syntax_prototype_subset_of_type(symbol_t *reference, symbol_t *target)
{
	if (!symbol_equal_type(reference, target))
	{
		if (!syntax_prototype_subset_of_component_type(reference, target))
		{
			return 0;
		}
		return 1;
	}

	if (symbol_check_type(reference, SYMBOL_ID) || symbol_check_type(reference, SYMBOL_NUMBER) || symbol_check_type(reference, SYMBOL_CHAR))
	{
		if (!syntax_subset_compare_id(reference, target))
		{
			return 0;
		}
		return 1;
	}
	
	uint64_t ref_counter = 0;
	symbol_t *a;
	for (a = reference->begin; a != reference->end; a = a->next)
	{
		ref_counter += 1;

		symbol_t *c;
		c = syntax_subset_of_reference_type(reference, a, a);
		if(!c)
		{
			c = a;
		}

		int32_t founded = 0;
		uint64_t tar_counter = 0;
		symbol_t *b;
		for (b = target->begin;b != target->end;b = b->next)
		{
			tar_counter += 1;

			if (tar_counter < ref_counter)
			{
				continue;
			}

			founded = 1;

			symbol_t *d;
			d = syntax_subset_of_reference_type(target, b, b);
			if(!d)
			{
				d = b;
			}
			
			if (!symbol_equal_type(c, d))
			{
				if (!syntax_prototype_subset_of_component_type(c, d))
				{
					return 0;
				}
				return 1;
			}

			if (symbol_check_type(c, SYMBOL_ID))
			{
				if (!syntax_subset_compare_id(c, d))
				{
					return 0;
				}
			}

			if (!syntax_prototype_subset_of_type(c, d))
			{
				return 0;
			}

			break;
		}

		if (!founded)
		{
			return 0;
		}
	}

	return 1;
}

static symbol_t *
syntax_subset_of_reference_type_in_generic(symbol_t *root, symbol_t *subroot, symbol_t *reference, symbol_t *target)
{
	symbol_t *a;
	for (a = reference->begin;a != reference->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			symbol_t *b;
			for (b = a->begin;b != a->end; b = b->next)
			{
				if(syntax_prototype_subset_of_type(b, target))
				{
					symbol_t *c;
					for (c = reference->begin;c != reference->end; c = c->next)
					{
						if (symbol_check_type(c, SYMBOL_TYPE))
						{
							symbol_t *d;
							for (d = c->begin;d != c->end;d = d->next)
							{
								symbol_t *e;
								e = syntax_subset_of_reference_type(root, a, d);
								if (e)
								{
									return e;
								}
								return d;
							}
						}
					}
				}
			}
		}
	}
	return NULL;
}

static symbol_t *
syntax_subset_of_reference_type_in_heritage(symbol_t *root, symbol_t *subroot, symbol_t *reference, symbol_t *target)
{
	symbol_t *a;
	for (a = reference->begin;a != reference->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			symbol_t *b;
			for (b = a->begin;b != a->end; b = b->next)
			{
				if(syntax_prototype_subset_of_type(b, target))
				{
					symbol_t *c;
					for (c = reference->begin;c != reference->end;c = c->next)
					{
						if (symbol_check_type(c, SYMBOL_TYPE))
						{
							symbol_t *d;
							for (d = c->begin;d != c->end;d = d->next)
							{
								symbol_t *e;
								e = syntax_subset_of_reference_type(root, a, d);
								if (e)
								{
									return e;
								}
								return d;
							}
						}
					}
				}
			}
		}
	}
	return NULL;
}

static symbol_t *
syntax_subset_of_reference_type_in_parameter(symbol_t *root, symbol_t *subroot, symbol_t *reference, symbol_t *target)
{
	symbol_t *a;
	for (a = reference->begin;a != reference->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			symbol_t *b;
			for (b = a->begin;b != a->end; b = b->next)
			{
				if(syntax_prototype_subset_of_type(b, target))
				{
					symbol_t *c;
					for (c = reference->begin;c != reference->end; c = c->next)
					{
						if (symbol_check_type(c, SYMBOL_TYPE))
						{
							symbol_t *d;
							for (d = c->begin;d != c->end;d = d->next)
							{
								symbol_t *e;
								e = syntax_subset_of_reference_type(root, a, d);
								if (e)
								{
									return e;
								}
								return d;
							}
						}
					}
				}
			}
		}
	}
	return NULL;
}

static symbol_t *
syntax_subset_of_reference_type(symbol_t *root, symbol_t *subset, symbol_t *target)
{
	if (symbol_check_type(root, SYMBOL_CLASS))
	{
		symbol_t *a;
		for (a = root->begin;(a != subset) && (a != root->end); a = a->next)
		{
			if (symbol_check_type(a, SYMBOL_GENERIC))
			{
				symbol_t *b;
				b = syntax_subset_of_reference_type_in_generic(root, subset, a, target);
				if (b)
				{
					return b;
				}
			}

			if (symbol_check_type(a, SYMBOL_HERITAGE))
			{
				symbol_t *b = NULL;
				b = syntax_subset_of_reference_type_in_heritage(root, subset, a, target);
				if (b)
				{
					return b;
				}
			}
		}

		if(root->parent)
		{
			return syntax_subset_of_reference_type(root->parent, root, target);
		}
	}
	
	if (symbol_check_type(root, SYMBOL_METHOD))
	{
		symbol_t *a;
		for (a = root->begin;(a != subset) && (a != root->end); a = a->next)
		{
			if (symbol_check_type(a, SYMBOL_GENERIC))
			{
				symbol_t *b;
				b = syntax_subset_of_reference_type_in_generic(root, subset, a, target);
				if (b)
				{
					return b;
				}
			}
		}

		if(root->parent)
		{
			return syntax_subset_of_reference_type(root->parent, root, target);
		}
	}
	
	if (symbol_check_type(root, SYMBOL_FUNCTION))
	{
		symbol_t *a;
		for (a = root->begin;(a != subset) && (a != root->end); a = a->next)
		{
			if (symbol_check_type(a, SYMBOL_GENERIC))
			{
				symbol_t *b;
				b = syntax_subset_of_reference_type_in_generic(root, subset, a, target);
				if (b)
				{
					return b;
				}
			}
		}

		if(root->parent)
		{
			return syntax_subset_of_reference_type(root->parent, root, target);
		}
	}
	
	if (symbol_check_type(root, SYMBOL_TYPE))
	{
		symbol_t *a;
		for (a = root->begin;(a != subset) && (a != root->end); a = a->next)
		{
			if (symbol_check_type(a, SYMBOL_GENERIC))
			{
				symbol_t *b;
				b = syntax_subset_of_reference_type_in_generic(root, subset, a, target);
				if (b)
				{
					return b;
				}
			}
			if (symbol_check_type(a, SYMBOL_HERITAGE))
			{
				symbol_t *b = NULL;
				b = syntax_subset_of_reference_type_in_heritage(root, subset, a, target);
				if (b)
				{
					return b;
				}
			}
		}
		if(root->parent)
		{
			return syntax_subset_of_reference_type(root->parent, root, target);
		}
	}

	if (root->parent)
	{
		return syntax_subset_of_reference_type(root->parent, root, target);
	}

	return NULL;
}





static symbol_t *
syntax_find_type_primary(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *applicant, symbol_t *target, symbol_t *arguments);

static int32_t
syntax_equivalent_of_type(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *type1, symbol_t *type2);

static int32_t
syntax_subset_of_type_by_heritage(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *type1, symbol_t *type2)
{
	if (type1->id == type2->id)
	{
		return 1;
	}

	symbol_t *a;
	for (a = type2->begin;a != type2->end;a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_HERITAGE))
		{
			symbol_t *type;
			type = syntax_extract_with(a, SYMBOL_TYPE);

			symbol_t *origin;
			origin = syntax_find_type_primary(graph, type2, a, type2, type, NULL);
			if (!origin)
			{
				syntax_error(graph, type, "reference of type not found");
				return 0;
			}

			int32_t result;
			result = syntax_equivalent_of_type(graph, type2, a, type1, origin);
			if (result)
			{
				return 1;
			}
		}
	}

	return 0;
}

static int32_t
syntax_subset_of_type_by_component(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *type1, symbol_t *type2)
{
	if(symbol_check_type(type2, SYMBOL_OR))
	{
		int32_t result = 1;
		symbol_t *a;
		for (a = type2->begin; a != type2->end; a = a->next)
		{
			if (symbol_check_type(a, SYMBOL_LEFT))
			{
				result |= syntax_subset_of_type_by_component(graph, root, subroot, type1, a);
			}
			if (symbol_check_type(a, SYMBOL_RIGHT))
			{
				result |= syntax_subset_of_type_by_component(graph, root, subroot, type1, a);
			}
		}
		return result;
	}
	
	if(symbol_check_type(type2, SYMBOL_AND))
	{
		int32_t result = 1;
		symbol_t *a;
		for (a = type2->begin; a != type2->end; a = a->next)
		{
			if (symbol_check_type(a, SYMBOL_LEFT))
			{
				result &= syntax_subset_of_type_by_component(graph, root, subroot, type1, a);
			}
			if (symbol_check_type(a, SYMBOL_RIGHT))
			{
				result &= syntax_subset_of_type_by_component(graph, root, subroot, type1, a);
			}
		}
		return result;
	}

	symbol_t *origin;
	origin = syntax_find_type_primary(graph, root, subroot, root, type2, NULL);
	if (!origin)
	{
		syntax_error(graph, type2, "reference of type not found");
		return 0;
	}

	return syntax_equivalent_of_type(graph, root, subroot, type1, origin);
}

static int32_t
syntax_subset_of_type_by_generic(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *type1, symbol_t *type2)
{
	if (type1->id == type2->id)
	{
		return 1;
	}

	symbol_t *type2_type;
	type2_type = syntax_extract_with(type2, SYMBOL_TYPE);
	if (type2_type)
	{
		if (symbol_check_type(type1, SYMBOL_GENERIC))
		{
			symbol_t *type1_type;
			type1_type = syntax_extract_with(type1, SYMBOL_TYPE);
			if (type1_type)
			{
				return syntax_subset_of_type_by_component(graph, root, subroot, type1_type, type2_type);
			}
		}
		return syntax_subset_of_type_by_component(graph, root, subroot, type1, type2_type);
	}

	if (symbol_check_type(type1, SYMBOL_GENERIC))
	{
		return 1;
	}

	return 0;
}

static int32_t
syntax_equivalent_of_type(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *type1, symbol_t *type2)
{
	if (type1->id == type2->id)
	{
		return 1;
	}

	if (symbol_check_type(type2, SYMBOL_TYPE) || symbol_check_type(type2, SYMBOL_CLASS))
	{
		return syntax_subset_of_type_by_heritage(graph, root, subroot, type1, type2);
	}
	
	if (symbol_check_type(type2, SYMBOL_GENERIC))
	{
		return syntax_subset_of_type_by_generic(graph, root, subroot, type1, type2);
	}

	return 0;
}




static symbol_t *
syntax_find_type(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *applicant, symbol_t *target);

static symbol_t *
syntax_subset_of_above(symbol_t *root, symbol_t *applicant)
{
	if (root->id == applicant->id)
	{
		return root;
	}

	if(root->parent)
	{
		symbol_t *result;
		result = syntax_subset_of_above(root->parent, applicant);
		if(result)
		{
			return result;
		}
	}
	return NULL;
}

static int32_t
syntax_match_composite(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *reference, symbol_t *target)
{
	uint64_t ref_counter = 0;
	uint64_t tar_counter = 0;

	int32_t use_found = 0;

	symbol_t *a;
	for (a = reference->begin;a != reference->end;a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_GENERIC))
		{
			ref_counter += 1;
			tar_counter = 0;
			symbol_t *b;
			for (b = target->begin;b != target->end;b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_ARGUMENT))
				{
					tar_counter += 1;
					if (tar_counter < ref_counter)
					{
						continue;
					}
					if (use_found)
					{
						syntax_error(graph, a, "type without value after parameter by value");
						return 0;
					}

					symbol_t *origin;
					origin = syntax_find_type_primary(graph, target, b, target, syntax_only(b), NULL);
					if (!origin)
					{
						syntax_error(graph, b, "reference of type not found");
						return 0;
					}

					if (syntax_equivalent_of_type(graph, reference, a, origin, a))
					{
						break;
					}
					syntax_error(graph, b, "reference of type not found");
					return 0;
				}
			}
			
			if (tar_counter != ref_counter)
			{
				symbol_t *value;
				value = syntax_extract_with(a, SYMBOL_VALUE);
				if (!value)
				{
					return 0;
				}
				use_found = 1;
			}
		}
	}

	tar_counter = 0;
	symbol_t *b;
	for (b = target->begin;b != target->end;b = b->next)
	{
		if (symbol_check_type(b, SYMBOL_ARGUMENT))
		{
			tar_counter += 1;
		}
	}

	if (tar_counter > ref_counter)
	{
		return 0;
	}

	return 1;
}

static symbol_t *
syntax_find_type_by_id(graph_t *graph, symbol_t *root, uint64_t type)
{
	if (root->id == type)
	{
		return root;
	}

	symbol_t *a;
	for (a = root->begin;(a != root->end);a = a->next)
	{
		if (a->id == type)
		{
			return a;
		}
	}

	if(root->parent)
	{
		return syntax_find_type_by_id(graph, root->parent, type);
	}

	return NULL;
}

static symbol_t *
syntax_find_type_by_target(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *applicant, symbol_t *target, symbol_t *arguments)
{
	if (symbol_check_type(target, SYMBOL_NULL))
	{
		symbol_t *result;
		result = syntax_find_type_by_id(graph, root, SYMBOL_NULL);
		if(result)
		{
			return result;
		}
	}

	if (symbol_check_type(target, SYMBOL_CHAR))
	{
		symbol_t *result;
		result = syntax_find_type_by_id(graph, root, SYMBOL_CHAR);
		if(result)
		{
			return result;
		}
	}

	if (symbol_check_type(target, SYMBOL_STRING))
	{
		symbol_t *result;
		result = syntax_find_type_by_id(graph, root, SYMBOL_STRING);
		if(result)
		{
			return result;
		}
	}

	if (symbol_check_type(target, SYMBOL_NUMBER))
	{
		symbol_t *result;
		result = syntax_find_type_by_id(graph, root, SYMBOL_NUMBER);
		if(result)
		{
			return result;
		}
	}

	if (symbol_check_type(target, SYMBOL_BOOLEAN))
	{
		symbol_t *result;
		result = syntax_find_type_by_id(graph, root, SYMBOL_BOOLEAN);
		if(result)
		{
			return result;
		}
	}

	symbol_t *a;
	for (a = root->begin;(a != root->end);a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_GENERIC))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				return a;
			}
		}

		if (!symbol_check_type(root, SYMBOL_CLASS) && !symbol_check_type(root, SYMBOL_MODULE))
		{
			if (a == subroot)
			{
				break;
			}
		}

		if (symbol_check_type(a, SYMBOL_IMPORT))
		{
			symbol_t *b;
			for (b = a->begin; b != a->end; b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_FIELD))
				{
					symbol_t *result;
					result = syntax_subset_exist_in_flag(b, target, SYMBOL_NAME);
					if (result && (result->id != target->id))
					{
						if (!!arguments)
						{
							if (syntax_match_composite(graph, root, subroot, b, arguments))
							{
								return b;
							}
							continue;
						}
						return b;
					}
				}
			}
		}

		if (symbol_check_type(a, SYMBOL_CLASS))
		{
			symbol_t *result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				if (!syntax_subset_of_above(root, applicant))
				{
					node_class_t *node_class = (node_class_t *)a->declaration->value;
					if ((node_class->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
					{
						continue;
					}
				}
				if (!!arguments)
				{
					if (syntax_match_composite(graph, root, subroot, a, arguments))
					{
						return a;
					}
					continue;
				}
				return a;
			}
		}

		if (symbol_check_type(a, SYMBOL_TYPE))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				if (!syntax_subset_of_above(root, applicant))
				{
					node_t *node = a->declaration;
					node_type_t *node_type = (node_type_t *)node->value;
					if ((node_type->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
					{
						continue;
					}
				}
				
				if (!!arguments)
				{
					if (syntax_match_composite(graph, root, subroot, a, arguments))
					{
						return a;
					}
					continue;
				}
				return a;
			}
		}
	}
	
	if(root->parent)
	{
		symbol_t *result;
		result = syntax_find_type_by_target(graph, root->parent, root, applicant, target, arguments);
		if(result)
		{
			return result;
		}
	}

	return NULL;
}

static symbol_t *
syntax_find_type_by_array(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *target)
{
	symbol_t *direct;
	direct = syntax_extract_with(target, SYMBOL_NAME);

	symbol_t *origin;
	origin = syntax_find_type_primary(graph, root, subroot, root, direct, NULL);
	if(!origin)
	{
		syntax_error(graph, direct, "direct type not found in array type, symbol(%lld)", direct->flags);
		return NULL;
	}

	symbol_t *index;
	index = syntax_extract_with(target, SYMBOL_INDEX);
	if (index)
	{
		if (!symbol_check_type(index, SYMBOL_NUMBER))
		{
			syntax_error(graph, direct, "array with invalid dimention, symbol(%lld)", direct->flags);
			return NULL;
		}
	}
	
	return target;
}

static symbol_t *
syntax_find_type_by_tuple(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *target)
{
	symbol_t *a;
	for (a = target->begin;(a != target->end);a = a->next)
	{
		symbol_t *origin;
		origin = syntax_find_type_primary(graph, target, a, target, a, NULL);
		if(!origin)
		{
			syntax_error(graph, a, "type not found in tuple type, symbol(%lld)", a->flags);
			return NULL;
		}
	}
	return target;
}

static symbol_t *
syntax_find_type_by_object(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *target)
{
	symbol_t *a;
	for (a = target->begin;(a != target->end);a = a->next)
	{
		symbol_t *value;
		value = syntax_extract_with(a, SYMBOL_VALUE);
		if (!value)
		{
			syntax_error(graph, a, "item in object type without type, symbol(%lld)", a->flags);
			return NULL;
		}

		symbol_t *origin;
		origin = syntax_find_type_primary(graph, target, a, target, value, NULL);
		if(!origin)
		{
			syntax_error(graph, a, "type not found in tuple type, symbol(%lld)", a->flags);
			return NULL;
		}
	}
	return target;
}

static symbol_t *
syntax_find_type_by_typeof(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *target)
{
	return syntax_find_type(graph, root, subroot, syntax_only(target));
}

static symbol_t *
syntax_find_type_by_composite(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *target)
{
	symbol_t *left;
	left = syntax_extract_with(target, SYMBOL_NAME);

	symbol_t *origin;
	origin = syntax_find_type_primary(graph, root, subroot, root, left, target);

	if(!origin)
	{
		syntax_error(graph, left, "lhs type not found in composite type, symbol(%lld)", left->flags);
		return NULL;
	}

	return origin;
}

static symbol_t *
syntax_find_type_by_attribute(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *target, symbol_t *arguments)
{
	symbol_t *left;
	left = syntax_extract_with(target, SYMBOL_LEFT);

	symbol_t *origin;
	origin = syntax_find_type_primary(graph, root, subroot, root, left, NULL);
	if (!origin)
	{
		syntax_error(graph, left, "lhs type not found in attribute type, symbol(%lld)", left->flags);
		return NULL;
	}

	symbol_t *right;
	right = syntax_extract_with(target, SYMBOL_RIGHT);

	symbol_t *result;
	result = syntax_find_type_primary(graph, origin, origin->end, origin, right, arguments);
	if (!result)
	{
		syntax_error(graph, right, "rhs type not found in attribute type, symbol(%lld)", right->flags);
		return NULL;
	}

	return result;
}

static symbol_t *
syntax_find_type_primary(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *applicant, symbol_t *target, symbol_t *arguments)
{
	if (symbol_check_type(target, SYMBOL_COMPOSITE))
	{
		return syntax_find_type_by_composite(graph, root, subroot, target);
	}

	if (symbol_check_type(target, SYMBOL_ATTR))
	{
		return syntax_find_type_by_attribute(graph, root, subroot, target, arguments);
	}

	if (symbol_check_type(target, SYMBOL_ITEM))
	{
		return syntax_find_type_by_array(graph, root, subroot, target);
	}

	if (symbol_check_type(target, SYMBOL_ARRAY))
	{
		return syntax_find_type_by_tuple(graph, root, subroot, target);
	}

	if (symbol_check_type(target, SYMBOL_OBJECT))
	{
		return syntax_find_type_by_object(graph, root, subroot, target);
	}

	if (symbol_check_type(target, SYMBOL_TYPEOF))
	{
		return syntax_find_type_by_typeof(graph, root, subroot, target);
	}

	if (
		symbol_check_type(target, SYMBOL_ID) || 
		symbol_check_type(target, SYMBOL_NULL) ||
		symbol_check_type(target, SYMBOL_CHAR) ||
		symbol_check_type(target, SYMBOL_STRING) ||
		symbol_check_type(target, SYMBOL_NUMBER) ||
		symbol_check_type(target, SYMBOL_BOOLEAN)
		)
	{
		return syntax_find_type_by_target(graph, root, subroot, applicant, target, arguments);
	}

	return NULL;
}

static symbol_t *
syntax_find_type(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *applicant, symbol_t *target)
{
	return syntax_find_type_primary(graph, root, subroot, applicant, target, NULL);
}




static symbol_t *
syntax_find_reference_primary(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *applicant, symbol_t *target, symbol_t *arguments, symbol_t *parameters);

static symbol_t *
syntax_find_reference_by_target(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *applicant, symbol_t *target, symbol_t *arguments, symbol_t *parameters);

static int32_t
syntax_subset_of_ellipsis(symbol_t *reference)
{
	symbol_t *a;
	for (a = reference->begin; a != reference->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			symbol_t *b;
			for (b = a->begin; b != a->end; b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_ELLIPSIS))
				{
					return 1;
				}
			}
		}
	}
	return 0;
}

static int32_t
syntax_match_parameters(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *reference, symbol_t *target)
{
	uint64_t ref_counter = 0;  
	symbol_t *a;
	for (a = reference->begin; a != reference->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_PARAMETER))
		{
			symbol_t *value;
			value = syntax_extract_with(a, SYMBOL_VALUE);
			if (value)
			{
				continue;
			}

			ref_counter += 1;
			uint64_t tar_counter = 0;
			symbol_t *b;
			for (b = target->begin; b != target->end; b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_PARAMETER))
				{
					tar_counter += 1;
					if (tar_counter < ref_counter)
					{
						continue;
					}

					if (syntax_subset_of_ellipsis(b))
					{
						return 1;
					}

					if (!syntax_equivalent_of_type(graph, target, b, a, b))
					{
						return 0;
					}
					break;
				}
			}
			
			if (tar_counter != ref_counter)
			{
				symbol_t *value;
				value = syntax_extract_with(a, SYMBOL_VALUE);
				if (value) {
					continue;
				}
				return 0;
			}
		}
	}

	
	uint64_t tar_counter = 0;
	
	for (a = target->begin; a != target->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_PARAMETER))
		{
			if (!ref_counter)
			{
				return 0;
			}

			tar_counter += 1;
			if (tar_counter <= ref_counter)
			{
				continue;
			}

			if (syntax_subset_of_ellipsis(a))
			{
				return 1;
			}
			
			symbol_t *value;
			value = syntax_extract_with(a, SYMBOL_VALUE);
			if (!value)
			{
				return 0;
			}
		}
	}

	return 1;
}

static int32_t
syntax_match_arguments(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *reference, symbol_t *target)
{
	uint64_t ref_counter = 0;  
	symbol_t *a;
	for (a = reference->begin; a != reference->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_PARAMETER))
		{
			symbol_t *value;
			value = syntax_extract_with(a, SYMBOL_VALUE);
			if (value)
			{
				continue;
			}

			ref_counter += 1;
			uint64_t tar_counter = 0;
			symbol_t *b;
			for (b = target->begin; b != target->end; b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_ARGUMENT))
				{
					tar_counter += 1;
					if (tar_counter < ref_counter)
					{
						continue;
					}

					if (syntax_subset_of_ellipsis(b))
					{
						return 1;
					}

					if (!syntax_equivalent_of_type(graph, target, b, a, b))
					{
						return 0;
					}
					break;
				}
			}
			
			if (tar_counter != ref_counter)
			{
				symbol_t *value;
				value = syntax_extract_with(a, SYMBOL_VALUE);
				if (value) {
					continue;
				}
				return 0;
			}
		}
	}

	
	uint64_t tar_counter = 0;
	
	for (a = target->begin; a != target->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_ARGUMENT))
		{
			if (!ref_counter)
			{
				return 0;
			}

			tar_counter += 1;
			if (tar_counter <= ref_counter)
			{
				continue;
			}

			if (syntax_subset_of_ellipsis(a))
			{
				return 1;
			}
			
			symbol_t *value;
			value = syntax_extract_with(a, SYMBOL_VALUE);
			if (!value)
			{
				return 0;
			}
		}
	}

	return 1;
}

static int32_t
syntax_match_fields(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *reference, symbol_t *target)
{
	uint64_t ref_counter = 0;
	uint64_t tar_counter = 0;

	symbol_t *a;
	for (a = reference->begin; a != reference->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_HERITAGE))
		{
			symbol_t *ref_type;
			ref_type = syntax_extract_with(a, SYMBOL_TYPE);

			symbol_t *ref_origin;
			ref_origin = syntax_find_type_primary(graph, reference, a, reference, ref_type, NULL);
			if (ref_origin)
			{
				syntax_error(graph, a, "reference of type not found");
				return 0;
			}

			ref_counter += 1;
			symbol_t *b;
			for (b = target->begin; b != target->end; b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_FIELD))
				{
					symbol_t *tar_type;
					tar_type = syntax_extract_with(b, SYMBOL_TYPE);

					symbol_t *tar_origin;
					tar_origin = syntax_find_type_primary(graph, target, a, target, tar_type, NULL);
					if (tar_origin)
					{
						syntax_error(graph, a, "reference of type not found");
						return 0;
					}

					if (syntax_equivalent_of_type(graph, target, b, ref_origin, tar_origin))
					{
						return 0;
					}
					tar_counter += 1;
					break;
				}
			}
		}
	}
	
	symbol_t *b;
	for (b = target->begin; b != target->end; b = b->next)
	{
		if (symbol_check_type(b, SYMBOL_FIELD))
		{
			symbol_t *tar_type;
			tar_type = syntax_extract_with(b, SYMBOL_TYPE);

			symbol_t *tar_origin;
			tar_origin = syntax_find_type_primary(graph, target, a, target, tar_type, NULL);
			if (tar_origin)
			{
				syntax_error(graph, a, "reference of type not found");
				return 0;
			}

			if (syntax_equivalent_of_type(graph, target, b, reference, tar_origin))
			{
				return 0;
			}
			tar_counter += 1;
			break;
		}
	}

	if (ref_counter != tar_counter)
	{
		return 0;
	}

	return 1;
}

static symbol_t *
syntax_find_reference_by_target(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *applicant, symbol_t *target, symbol_t *arguments, symbol_t *parameters)
{
	symbol_t *a;
	for (a = root->begin;(a != root->end);a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_HERITAGE))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				symbol_t *type;
				type = syntax_extract_with(target, SYMBOL_TYPE);

				return syntax_find_type_primary(graph, root, a, root, type, NULL);
			}
		}

		if (symbol_check_type(a, SYMBOL_FIELD))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				symbol_t *type;
				type = syntax_extract_with(target, SYMBOL_TYPE);

				return syntax_find_type_primary(graph, root, a, root, type, NULL);
			}
		}

		if (symbol_check_type(a, SYMBOL_VAR))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				if (!syntax_subset_of_above(root, applicant))
				{
					node_t *node = a->declaration;
					node_class_t *node_class = (node_class_t *)node->value;
					if ((node_class->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
					{
						continue;
					}
				}
				return a;
			}
		}

		if (symbol_check_type(a, SYMBOL_DEFINE))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				return a;
			}
		}

		if (symbol_check_type(a, SYMBOL_IF))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				return a;
			}
		}

		if (symbol_check_type(a, SYMBOL_FOR))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				return a;
			}
		}

		if (symbol_check_type(a, SYMBOL_FORIN))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				return a;
			}
		}

		if (symbol_check_type(a, SYMBOL_PARAMETER))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				return a;
			}
		}

		if (!symbol_check_type(root, SYMBOL_CLASS) && !symbol_check_type(root, SYMBOL_MODULE))
		{
			if (a == subroot)
			{
				break;
			}
		}

		if (symbol_check_type(a, SYMBOL_IMPORT))
		{
			symbol_t *b;
			for (b = a->begin; b != a->end; b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_FIELD))
				{
					symbol_t *result;
					result = syntax_subset_exist_in_flag(b, target, SYMBOL_NAME);
					if (result && (result->id != target->id))
					{
						if (!!arguments)
						{
							if (syntax_match_composite(graph, root, subroot, b, arguments))
							{
								return b;
							}
							continue;
						}
						return b;
					}
				}
			}
		}

		if (symbol_check_type(a, SYMBOL_CLASS))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				if (!syntax_subset_of_above(root, applicant))
				{
					node_t *node = a->declaration;
					node_class_t *node_class = (node_class_t *)node->value;
					if ((node_class->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
					{
						continue;
					}
				}
				if (!!arguments)
				{
					if (!syntax_match_composite(graph, root, subroot, a, arguments))
					{
						continue;
					}
				}
				
				symbol_t *b;
				for (b = a->begin;(b != a->end);b = b->next)
				{
					if (symbol_check_type(b, SYMBOL_METHOD))
					{
						symbol_t *name = syntax_extract_with(b, SYMBOL_NAME);
						if (!syntax_subset_compare_string(name, "init"))
						{
							continue;
						}
						if (!!parameters)
						{
							if (!syntax_match_arguments(graph, a, b, b, parameters))
							{
								continue;
							}
						}
						
						return a;
					}
				}
			}
		}

		if (symbol_check_type(a, SYMBOL_ENUM))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				if (!syntax_subset_of_above(root, applicant))
				{
					node_t *node = a->declaration;
					node_enum_t *node_enum = (node_enum_t *)node->value;
					if ((node_enum->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
					{
						continue;
					}
				}
				return a;
			}
		}

		if (symbol_check_type(a, SYMBOL_PROPERTY))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				if (!syntax_subset_of_above(root, applicant))
				{
					node_t *node = a->declaration;
					node_property_t *node_property = (node_property_t *)node->value;
					if ((node_property->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
					{
						continue;
					}
				}
				return a;
			}
		}

		if (symbol_check_type(a, SYMBOL_TYPE))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				if (symbol_check_type(root, SYMBOL_MODULE) && (root != applicant))
				{
					node_t *node = a->declaration;
					node_type_t *node_class = (node_type_t *)node->value;
					if ((node_class->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
					{
						continue;
					}
				}
				if (!!arguments)
				{
					if (syntax_match_composite(graph, root, subroot, a, arguments))
					{
						return a;
					}
					continue;
				}
				return a;
			}
		}

		if (symbol_check_type(a, SYMBOL_METHOD))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				if (!syntax_subset_of_above(root, applicant))
				{
					node_t *node = a->declaration;
					node_func_t *node_func = (node_func_t *)node->value;
					if ((node_func->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
					{
						continue;
					}
				}

				if (!!arguments)
				{
					if (!syntax_match_composite(graph, root, subroot, a, arguments))
					{
						continue;
					}
				}

				if (!!parameters)
				{
					if (!syntax_match_arguments(graph, root, subroot, a, parameters))
					{
						continue;
					}
				}
				
				return a;
			}
		}

		if (symbol_check_type(a, SYMBOL_FUNCTION))
		{
			symbol_t *result;
			result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
			if (result && (result->id != target->id))
			{
				if (!syntax_subset_of_above(root, applicant))
				{
					node_t *node = a->declaration;
					node_func_t *node_func = (node_func_t *)node->value;
					if ((node_func->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
					{
						continue;
					}
				}

				symbol_t *field;
				field = syntax_extract_with(a, SYMBOL_FIELD);
				if (!!field)
				{
					continue;
				}

				if (!!arguments)
				{
					if (!syntax_match_composite(graph, root, subroot, a, arguments))
					{
						continue;
					}
				}

				if (!!parameters)
				{
					if (!syntax_match_arguments(graph, root, subroot, a, parameters))
					{
						continue;
					}
				}
				
				return a;
			}
		}
	}

	if (symbol_check_type(root, SYMBOL_TYPE))
	{
		symbol_t *parent = root->parent;
		symbol_t *a;
		for (a = parent->begin;(a != parent->end);a = a->next)
		{
			if (a == subroot)
			{
				break;
			}

			if (symbol_check_type(a, SYMBOL_FUNCTION))
			{
				symbol_t *result;
				result = syntax_subset_exist_in_flag(a, target, SYMBOL_NAME);
				if (result && (result->id != target->id))
				{
					if (!syntax_subset_of_above(root, applicant))
					{
						node_t *node = a->declaration;
						node_func_t *node_func = (node_func_t *)node->value;
						if ((node_func->flag & PARSER_MODIFIER_EXPORT) != PARSER_MODIFIER_EXPORT)
						{
							continue;
						}
					}

					if (!syntax_match_fields(graph, root, subroot, root, a))
					{
						continue;
					}

					if (!!arguments)
					{
						if (!syntax_match_composite(graph, root, subroot, a, arguments))
						{
							continue;
						}
					}

					if (!!parameters)
					{
						if (!syntax_match_arguments(graph, root, subroot, a, parameters))
						{
							continue;
						}
					}
					
					return a;
				}
			}
		}
	}
	
	if(root->parent)
	{
		symbol_t *result;
		result = syntax_find_reference_by_target(graph, root->parent, root, applicant, target, arguments, parameters);
		if(result)
		{
			return result;
		}
	}

	return NULL;
}

static symbol_t *
syntax_find_reference_by_composite(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *target, symbol_t *parameters)
{
	symbol_t *left;
	left = syntax_extract_with(target, SYMBOL_NAME);

	symbol_t *origin;
	origin = syntax_find_reference_primary(graph, root, subroot, root, left, target, parameters);

	if(!origin)
	{
		syntax_error(graph, left, "lhs type not found in composite type, symbol(%lld)", left->flags);
		return NULL;
	}

	return origin;
}

static symbol_t *
syntax_find_reference_by_call(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *target)
{
	symbol_t *left;
	left = syntax_extract_with(target, SYMBOL_NAME);

	symbol_t *origin;
	origin = syntax_find_reference_primary(graph, root, subroot, root, left, NULL, target);

	if(!origin)
	{
		syntax_error(graph, left, "lhs type not found in callable type, symbol(%lld)", left->flags);
		return NULL;
	}

	return origin;
}

static symbol_t *
syntax_find_reference_by_attribute(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *target, symbol_t *arguments, symbol_t *parameters)
{
	symbol_t *left;
	left = syntax_extract_with(target, SYMBOL_LEFT);

	symbol_t *origin;
	origin = syntax_find_reference_primary(graph, root, subroot, root, left, NULL, NULL);
	if (!origin)
	{
		syntax_error(graph, left, "lhs type not found in attribute type, symbol(%lld)", left->flags);
		return NULL;
	}

	symbol_t *right;
	right = syntax_extract_with(target, SYMBOL_RIGHT);

	symbol_t *result;
	result = syntax_find_reference_primary(graph, origin, origin->end, origin, right, arguments, parameters);
	if (!result)
	{
		syntax_error(graph, right, "rhs type not found in attribute type, symbol(%lld)", right->flags);
		return NULL;
	}

	return result;
}

static symbol_t *
syntax_find_reference_primary(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *applicant, symbol_t *target, symbol_t *arguments, symbol_t *parameters)
{
	if (symbol_check_type(target, SYMBOL_COMPOSITE))
	{
		return syntax_find_reference_by_composite(graph, root, subroot, target, parameters);
	}

	if (symbol_check_type(target, SYMBOL_CALL))
	{
		return syntax_find_reference_by_call(graph, root, subroot, target);
	}

	if (symbol_check_type(target, SYMBOL_ATTR))
	{
		return syntax_find_reference_by_attribute(graph, root, subroot, target, arguments, parameters);
	}

	if (symbol_check_type(target, SYMBOL_ID))
	{
		return syntax_find_reference_by_target(graph, root, subroot, applicant, target, arguments, parameters);
	}

	return NULL;
}

static symbol_t *
syntax_find_reference(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *applicant, symbol_t *target)
{
	return syntax_find_reference_primary(graph, root, subroot, applicant, target, NULL, NULL);
}









static response_t *
syntax_expression(graph_t *graph, symbol_t *current);

static response_t *
syntax_postfix(graph_t *graph, symbol_t *current);

static symbol_t *
syntax_bitwise_or(graph_t *graph, symbol_t *current);

static response_t *
syntax_block(graph_t *graph, symbol_t *current);

static response_t *
syntax_function(graph_t *graph, symbol_t *current);

static response_t *
syntax_parameter(graph_t *graph, symbol_t *current);


static response_t *
syntax_lookup_bracket(graph_t *graph, response_t *target, symbol_t *applicant, symbol_t *arguments)
{
	response_t *response = response_create();
	
	iresponse_t *a;
	for (a = target->begin;a != target->end;a = a->next)
	{
		if (a->type == RESPONSE_TYPE_SYMBOL)
		{
			symbol_t *scope = (symbol_t *)a->value;

			symbol_t *method;
			method = syntax_find_by_bracket(graph, scope, applicant, arguments);
			if (!method)
			{
				return NULL;
			}

			response_t *result;
			result = syntax_return_of(graph, scope, method, arguments);
			if (!result)
			{
				return NULL;
			}

			if (response_count(result) < 2)
			{
				iresponse_t *b, *n;
				for (b = result->begin;b != result->end;b = n)
				{
					n = b->next;
					response_unlink(result, b);
					response_link(response, response->end, b);
				}
				response_destroy(result);
			}
			else
			{
				iresponse_t *check;
				check = response_rpush(response, RESPONSE_TYPE_HYBRID, result);
				if (!check)
				{
					return NULL;
				}
			}
			continue;
		}

		if (a->type == RESPONSE_TYPE_HYBRID)
		{
			response_t *hybrid = (response_t *)a->value;
			response_t *result;
			result = syntax_lookup_bracket(graph, hybrid, applicant, arguments);
			if (!result)
			{
				return NULL;
			}
			iresponse_t *check;
			check = response_rpush(response, RESPONSE_TYPE_HYBRID, result);
			if (!check)
			{
				return NULL;
			}
		}
	}
	return response;
}



static response_t *
syntax_primary(graph_t *graph, symbol_t *current)
{
	if (symbol_check_type(current, SYMBOL_FUNCTION))
	{
		return syntax_function(graph, current);
	}

	response_t *response = response_create();

	iresponse_t *iresponse;
	iresponse = response_rpush(response, RESPONSE_TYPE_SYMBOL, current);
	if (!iresponse)
	{
		return NULL;
	}

	return response;
}

static response_t *
syntax_attribute(graph_t *graph, symbol_t *current)
{
	symbol_t *symbol_left;
	symbol_left = syntax_extract_with(current, SYMBOL_LEFT);

	symbol_t *symbol_right;
	symbol_right = syntax_extract_with(current, SYMBOL_RIGHT);
	
	if (symbol_check_type(symbol_left, SYMBOL_ID))
	{
		symbol_t *applicant = current->parent;

		symbol_t *scope;
		scope = syntax_find(graph, current->parent, applicant, symbol_left);
		if (!scope)
		{
			syntax_error(graph, symbol_left, "scope of attribute not found");
			return NULL;
		}

		symbol_t *attribute;
		attribute = syntax_find_by_attribute(graph, scope, applicant, symbol_right);
		if (!attribute)
		{
			syntax_error(graph, scope, "attribute (%lld:%lld) not found", 
				symbol_right->declaration->position.line, symbol_right->declaration->position.column);
			return NULL;
		}

		response_t *response;
		response = syntax_type_of(graph, scope, attribute);
		if (!response)
		{
			return NULL;
		}

		return response;
	}
	else
	{
		response_t *response;
		response = syntax_postfix(graph, symbol_left);
		if (!response)
		{
			return NULL;
		}

		return syntax_lookup_argument(graph, response, current, symbol_right);
	}

	return NULL;
}

static response_t *
syntax_composite(graph_t *graph, symbol_t *current)
{
	symbol_t *symbol_name;
	symbol_name = syntax_extract_with(current, SYMBOL_NAME);
	if (symbol_check_type(symbol_name, SYMBOL_CALL))
	{
		syntax_error(graph, symbol_name, "composite after call");
		return NULL;
	}

	symbol_t *arguments;
	arguments = syntax_only_with(current, SYMBOL_ARGUMENTS);
	if (!arguments)
	{
		syntax_error(graph, symbol_name, "composite without arguments");
		return NULL;
	}
	
	if (symbol_check_type(symbol_name, SYMBOL_ID))
	{
		symbol_t *applicant = current->parent;

		symbol_t *scope;
		scope = syntax_find(graph, current->parent, applicant, symbol_name);
		if (!scope)
		{
			syntax_error(graph, symbol_name, "scope of composite not found");
			return NULL;
		}

		symbol_t *element;
		element = syntax_find_by_composite(graph, scope, applicant, arguments);
		if (!element)
		{
			syntax_error(graph, scope, "composite not found");
			return NULL;
		}

		response_t *response = response_create();

		iresponse_t *iresponse;
		iresponse = response_rpush(response, RESPONSE_TYPE_SYMBOL, element);
		if (!iresponse)
		{
			return NULL;
		}

		return response;
	}
	else
	{
		response_t *response;
		response = syntax_postfix(graph, symbol_name);
		if (!response)
		{
			return NULL;
		}

		return syntax_lookup_composite(graph, response, current, arguments);
	}

	return NULL;
}

static response_t *
syntax_call(graph_t *graph, symbol_t *current)
{
	symbol_t *symbol_name;
	symbol_name = syntax_extract_with(current, SYMBOL_NAME);

	symbol_t *arguments;
	arguments = syntax_only_with(current, SYMBOL_ARGUMENTS);
	if (!arguments)
	{
		syntax_error(graph, symbol_name, "bracket without arguments");
		return NULL;
	}
	
	if (symbol_check_type(symbol_name, SYMBOL_ID))
	{
		symbol_t *applicant = current->parent;

		symbol_t *scope;
		scope = syntax_find(graph, current->parent, applicant, symbol_name);
		if (!scope)
		{
			syntax_error(graph, symbol_name, "scope of bracket not found");
			return NULL;
		}

		symbol_t *method;
		method = syntax_find_by_call(graph, scope, applicant, arguments);
		if (!method)
		{
			syntax_error(graph, scope, "function of bracket not found");
			return NULL;
		}

		response_t *response;
		response = syntax_return_of(graph, scope, method, arguments);
		if (!response)
		{
			return NULL;
		}

		return response;
	}
	else
	{
		response_t *response;
		response = syntax_postfix(graph, symbol_name);
		if (!response)
		{
			return NULL;
		}

		return syntax_lookup_call(graph, response, current, arguments);
	}

	return NULL;
}

static response_t *
syntax_item(graph_t *graph, symbol_t *current)
{
	symbol_t *symbol_name;
	symbol_name = syntax_extract_with(current, SYMBOL_NAME);
	if (symbol_check_type(symbol_name, SYMBOL_CALL))
	{
		syntax_error(graph, symbol_name, "bracket after call");
		return NULL;
	}

	symbol_t *arguments;
	arguments = syntax_only_with(current, SYMBOL_ARGUMENTS);
	if (!arguments)
	{
		syntax_error(graph, symbol_name, "bracket without arguments");
		return NULL;
	}
	
	if (symbol_check_type(symbol_name, SYMBOL_ID))
	{
		symbol_t *applicant = current->parent;

		symbol_t *scope;
		scope = syntax_find(graph, current->parent, applicant, symbol_name);
		if (!scope)
		{
			syntax_error(graph, symbol_name, "scope of bracket not found");
			return NULL;
		}

		symbol_t *method;
		method = syntax_find_by_bracket(graph, scope, applicant, arguments);
		if (!method)
		{
			syntax_error(graph, scope, "function of bracket not found");
			return NULL;
		}

		response_t *response;
		response = syntax_return_of(graph, scope, method, arguments);
		if (!response)
		{
			return NULL;
		}

		return response;
	}
	else
	{
		response_t *response;
		response = syntax_postfix(graph, symbol_name);
		if (!response)
		{
			return NULL;
		}

		return syntax_lookup_bracket(graph, response, current, arguments);
	}

	return NULL;
}

static response_t *
syntax_postfix(graph_t *graph, symbol_t *current)
{
	if (symbol_check_type(current, SYMBOL_COMPOSITE))
	{
		return syntax_composite(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_CALL))
	{
		return syntax_call(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_ITEM))
	{
		return syntax_item(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_ATTR))
	{
		return syntax_attribute(graph, current);
	}
	else
	{
		return syntax_primary(graph, current);
	}
}

static response_t *
syntax_prefix(graph_t *graph, symbol_t *current)
{
	if (
		symbol_check_type(current, SYMBOL_TILDE) || 
		symbol_check_type(current, SYMBOL_NOT) ||
		symbol_check_type(current, SYMBOL_NEG) ||
		symbol_check_type(current, SYMBOL_POS) ||
		symbol_check_type(current, SYMBOL_AWAIT) ||
		symbol_check_type(current, SYMBOL_SIZEOF) ||
		symbol_check_type(current, SYMBOL_TYPEOF))
	{
		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);

		response_t *response_right;
		response_right = syntax_prefix(graph, right);
		if(!response_right)
		{
			return NULL;
		}
		return response_right;
	}
	else
	{
		response_t *response;
		response = syntax_postfix(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
}

static response_t *
syntax_multiplicative(graph_t *graph, symbol_t *current)
{
	if (
		symbol_check_type(current, SYMBOL_MUL) || 
		symbol_check_type(current, SYMBOL_DIV) ||
		symbol_check_type(current, SYMBOL_MOD))
	{
		symbol_t *left;
		left = syntax_extract_with(current, SYMBOL_LEFT);
		
		response_t *response_left;
		response_left = syntax_multiplicative(graph, left);
		if(!response_left)
		{
			return NULL;
		}

		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_prefix(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		symbol_t *method;
		if (symbol_check_type(current, SYMBOL_MUL))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "*");
			if (!method)
			{
				syntax_error(graph, left, "does not include * operator");
				return NULL;
			}
		}
		else
		if (symbol_check_type(current, SYMBOL_DIV))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "/");
			if (!method)
			{
				syntax_error(graph, left, "does not include / operator");
				return NULL;
			}
		}
		else
		if (symbol_check_type(current, SYMBOL_MOD))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "%");
			if (!method)
			{
				syntax_error(graph, left, "does not include %% operator");
				return NULL;
			}
		}

		response_t *result;
		result = syntax_return_of_operator(graph, method);
		if (!result)
		{
			return NULL;
		}

		return result;
	}
	else
	{
		response_t *response;
		response = syntax_prefix(graph, current);
		if(!response)
		{
			return NULL;
		}
	}
	return response;
}

static response_t *
syntax_addative(graph_t *graph, symbol_t *current)
{
	if (
		symbol_check_type(current, SYMBOL_PLUS) || 
		symbol_check_type(current, SYMBOL_MINUS))
	{
		symbol_t *left;
		left = syntax_extract_with(current, SYMBOL_LEFT);
		
		response_t *response_left;
		response_left = syntax_addative(graph, left);
		if(!response_left)
		{
			return NULL;
		}

		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_multiplicative(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		symbol_t *method;
		if (symbol_check_type(current, SYMBOL_PLUS))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "+");
			if (!method)
			{
				syntax_error(graph, left, "does not include + operator");
				return NULL;
			}
		}
		else
		if (symbol_check_type(current, SYMBOL_MINUS))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "-");
			if (!method)
			{
				syntax_error(graph, left, "does not include - operator");
				return NULL;
			}
		}

		response_t *result;
		result = syntax_return_of_operator(graph, method);
		if (!result)
		{
			return NULL;
		}

		return result;
	}
	else
	{
		response_t *response;
		response = syntax_multiplicative(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
}

static response_t *
syntax_shifting(graph_t *graph, symbol_t *current)
{
	if (
		symbol_check_type(current, SYMBOL_SHL) || 
		symbol_check_type(current, SYMBOL_SHR))
	{
		symbol_t *left;
		left = syntax_extract_with(current, SYMBOL_LEFT);
		
		response_t *response_left;
		response_left = syntax_shifting(graph, left);
		if(!response_left)
		{
			return NULL;
		}

		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_addative(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		symbol_t *method;
		if (symbol_check_type(current, SYMBOL_SHL))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "<<");
			if (!method)
			{
				syntax_error(graph, left, "does not include << operator");
				return NULL;
			}
		}
		else
		if (symbol_check_type(current, SYMBOL_SHR))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, ">>");
			if (!method)
			{
				syntax_error(graph, left, "does not include >> operator");
				return NULL;
			}
		}

		response_t *result;
		result = syntax_return_of_operator(graph, method);
		if (!result)
		{
			return NULL;
		}

		return result;
	} else {
		response_t *response;
		response = syntax_addative(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
}

static response_t *
syntax_relational(graph_t *graph, symbol_t *current)
{
	if (
		symbol_check_type(current, SYMBOL_LT) || 
		symbol_check_type(current, SYMBOL_GT) || 
		symbol_check_type(current, SYMBOL_LE) ||
		symbol_check_type(current, SYMBOL_GE))
	{
		symbol_t *left;
		left = syntax_extract_with(current, SYMBOL_LEFT);
		
		response_t *response_left;
		response_left = syntax_relational(graph, left);
		if(!response_left)
		{
			return NULL;
		}

		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_shifting(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		symbol_t *method;
		if (symbol_check_type(current, SYMBOL_LT))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "<");
			if (!method)
			{
				syntax_error(graph, left, "does not include < operator");
				return NULL;
			}
		}
		else
		if (symbol_check_type(current, SYMBOL_GT))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, ">");
			if (!method)
			{
				syntax_error(graph, left, "does not include > operator");
				return NULL;
			}
		}
		else
		if (symbol_check_type(current, SYMBOL_LE))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "<=");
			if (!method)
			{
				syntax_error(graph, left, "does not include <= operator");
				return NULL;
			}
		}
		else
		if (symbol_check_type(current, SYMBOL_GE))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, ">=");
			if (!method)
			{
				syntax_error(graph, left, "does not include >= operator");
				return NULL;
			}
		}

		response_t *result;
		result = syntax_return_of_operator(graph, method);
		if (!result)
		{
			return NULL;
		}

		return result;
	} else {
		response_t *response;
		response = syntax_shifting(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
}

static symbol_t *
syntax_equality(graph_t *graph, symbol_t *current)
{
	if (symbol_check_type(current, SYMBOL_IN) || symbol_check_type(current, SYMBOL_EXTENDS))
	{
		syntax_error(graph, current, "unexpected");
		return NULL;
	}

	if (
		symbol_check_type(current, SYMBOL_EQ) || 
		symbol_check_type(current, SYMBOL_NEQ))
	{
		symbol_t *left;
		left = syntax_extract_with(current, SYMBOL_LEFT);
		
		response_t *response_left;
		response_left = syntax_equality(graph, left);
		if(!response_left)
		{
			return NULL;
		}

		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_relational(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		symbol_t *method;
		if (symbol_check_type(current, SYMBOL_EQ))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "==");
			if (!method)
			{
				syntax_error(graph, left, "does not include == operator");
				return NULL;
			}
		}
		else
		if (symbol_check_type(current, SYMBOL_NEQ))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "-=");
			if (!method)
			{
				syntax_error(graph, left, "does not include -= operator");
				return NULL;
			}
		}

		response_t *result;
		result = syntax_return_of_operator(graph, method);
		if (!result)
		{
			return NULL;
		}

		return result;
	}
	else
	{
		response_t *response;
		response = syntax_relational(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
}

static response_t *
syntax_bitwise_and(graph_t *graph, symbol_t *current)
{
	if (symbol_check_type(current, SYMBOL_AND))
	{
		symbol_t *left;
		left = syntax_extract_with(current, SYMBOL_LEFT);
		
		response_t *response_left;
		response_left = syntax_bitwise_and(graph, left);
		if(!response_left)
		{
			return NULL;
		}

		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_equality(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		symbol_t *method;
		if (symbol_check_type(current, SYMBOL_AND))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "&");
			if (!method)
			{
				syntax_error(graph, left, "does not include & operator");
				return NULL;
			}
		}

		response_t *result;
		result = syntax_return_of_operator(graph, method);
		if (!result)
		{
			return NULL;
		}

		return result;
	}
	else
	{
		response_t *response;
		response = syntax_equality(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
	return current;
}

static response_t *
syntax_bitwise_xor(graph_t *graph, symbol_t *current)
{
	if (symbol_check_type(current, SYMBOL_XOR))
	{
		symbol_t *left;
		left = syntax_extract_with(current, SYMBOL_LEFT);
		
		response_t *response_left;
		response_left = syntax_bitwise_xor(graph, left);
		if(!response_left)
		{
			return NULL;
		}

		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_bitwise_and(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		symbol_t *method;
		if (symbol_check_type(current, SYMBOL_XOR))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "^");
			if (!method)
			{
				syntax_error(graph, left, "does not include & operator");
				return NULL;
			}
		}

		response_t *result;
		result = syntax_return_of_operator(graph, method);
		if (!result)
		{
			return NULL;
		}

		return result;
	}
	else
	{
		response_t *response;
		response = syntax_bitwise_and(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
}

static response_t *
syntax_bitwise_or(graph_t *graph, symbol_t *current)
{
	if (symbol_check_type(current, SYMBOL_OR))
	{
		symbol_t *left;
		left = syntax_extract_with(current, SYMBOL_LEFT);
		
		response_t *response_left;
		response_left = syntax_bitwise_and(graph, left);
		if(!response_left)
		{
			return NULL;
		}

		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_bitwise_xor(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		symbol_t *method;
		if (symbol_check_type(current, SYMBOL_OR))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "|");
			if (!method)
			{
				syntax_error(graph, left, "does not include | operator");
				return NULL;
			}
		}

		response_t *result;
		result = syntax_return_of_operator(graph, method);
		if (!result)
		{
			return NULL;
		}

		return result;
	}
	else
	{
		response_t *response;
		response = syntax_bitwise_xor(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
}

static response_t *
syntax_logical_and(graph_t *graph, symbol_t *current)
{
	if (symbol_check_type(current, SYMBOL_LAND))
	{
		symbol_t *left;
		left = syntax_extract_with(current, SYMBOL_LEFT);
		
		response_t *response_left;
		response_left = syntax_logical_and(graph, left);
		if(!response_left)
		{
			return NULL;
		}

		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_bitwise_or(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		symbol_t *method;
		if (symbol_check_type(current, SYMBOL_LAND))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "&&");
			if (!method)
			{
				syntax_error(graph, left, "does not include && operator");
				return NULL;
			}
		}

		response_t *result;
		result = syntax_return_of_operator(graph, method);
		if (!result)
		{
			return NULL;
		}

		return result;
	}
	else
	{
		response_t *response;
		response = syntax_bitwise_or(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
}

static response_t *
syntax_logical_or(graph_t *graph, symbol_t *current)
{
	if (symbol_check_type(current, SYMBOL_LOR))
	{
		symbol_t *left;
		left = syntax_extract_with(current, SYMBOL_LEFT);
		
		response_t *response_left;
		response_left = syntax_logical_or(graph, left);
		if(!response_left)
		{
			return NULL;
		}

		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_logical_and(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		symbol_t *method;
		if (symbol_check_type(current, SYMBOL_LOR))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "||");
			if (!method)
			{
				syntax_error(graph, left, "does not include || operator");
				return NULL;
			}
		}

		response_t *result;
		result = syntax_return_of_operator(graph, method);
		if (!result)
		{
			return NULL;
		}

		return result;
	}
	else
	{
		response_t *response;
		response = syntax_logical_and(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
}

static response_t *
syntax_conditional(graph_t *graph, symbol_t *current)
{
	if (symbol_check_type(current, SYMBOL_CONDITIONAL))
	{
		symbol_t *expression_true;
		expression_true = syntax_extract_with(current, SYMBOL_TRUE);

		response_t *response_true;
		response_true = syntax_conditional(graph, expression_true);
		if(!response_true)
		{
			return NULL;
		}

		symbol_t *expression_false;
		expression_false = syntax_extract_with(current, SYMBOL_FALSE);

		response_t *response_false;
		response_false = syntax_conditional(graph, expression_false);
		if(!response_false)
		{
			return NULL;
		}

		response_t *response = response_create();

		iresponse_t *check;
		check = response_rpush(response, RESPONSE_TYPE_HYBRID, response_true);
		if (!check)
		{
			return NULL;
		}

		check = response_rpush(response, RESPONSE_TYPE_HYBRID, response_false);
		if (!check)
		{
			return NULL;
		}

		return response;
	}
	else
	{
		response_t *response;
		response = syntax_logical_or(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
}

static response_t *
syntax_expression(graph_t *graph, symbol_t *current)
{
	return syntax_conditional(graph, current);
}



static response_t *
syntax_assign(graph_t *graph, symbol_t *current)
{
	if (
		symbol_check_type(current, SYMBOL_ADD_ASSIGN) ||
		symbol_check_type(current, SYMBOL_SUB_ASSIGN) ||
		symbol_check_type(current, SYMBOL_DIV_ASSIGN) ||
		symbol_check_type(current, SYMBOL_MUL_ASSIGN) ||
		symbol_check_type(current, SYMBOL_MOD_ASSIGN) ||
		symbol_check_type(current, SYMBOL_AND_ASSIGN) ||
		symbol_check_type(current, SYMBOL_OR_ASSIGN) ||
		symbol_check_type(current, SYMBOL_SHL_ASSIGN) ||
		symbol_check_type(current, SYMBOL_SHR_ASSIGN)
		)
	{
		symbol_t *left;
		left = syntax_extract_with(current, SYMBOL_LEFT);
		
		response_t *response_left;
		response_left = syntax_expression(graph, left);
		if(!response_left)
		{
			return NULL;
		}

		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_expression(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		symbol_t *method;
		if (symbol_check_type(current, SYMBOL_ADD_ASSIGN))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "+");
			if (!method)
			{
				syntax_error(graph, left, "does not include + operator");
				return NULL;
			}
		}

		else if (symbol_check_type(current, SYMBOL_SUB_ASSIGN))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "-");
			if (!method)
			{
				syntax_error(graph, left, "does not include - operator");
				return NULL;
			}
		}

		else if (symbol_check_type(current, SYMBOL_DIV_ASSIGN))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "/");
			if (!method)
			{
				syntax_error(graph, left, "does not include / operator");
				return NULL;
			}
		}

		else if (symbol_check_type(current, SYMBOL_MUL_ASSIGN))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "*");
			if (!method)
			{
				syntax_error(graph, left, "does not include * operator");
				return NULL;
			}
		}

		else if (symbol_check_type(current, SYMBOL_MOD_ASSIGN))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "*");
			if (!method)
			{
				syntax_error(graph, left, "does not include %% operator");
				return NULL;
			}
		}

		else if (symbol_check_type(current, SYMBOL_AND_ASSIGN))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "&");
			if (!method)
			{
				syntax_error(graph, left, "does not include & operator");
				return NULL;
			}
		}

		else if (symbol_check_type(current, SYMBOL_OR_ASSIGN))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "|");
			if (!method)
			{
				syntax_error(graph, left, "does not include | operator");
				return NULL;
			}
		}

		else if (symbol_check_type(current, SYMBOL_SHL_ASSIGN))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, "<<");
			if (!method)
			{
				syntax_error(graph, left, "does not include << operator");
				return NULL;
			}
		}

		else if (symbol_check_type(current, SYMBOL_SHR_ASSIGN))
		{
			method = syntax_find_method_by_response(graph, response_left, response_right, ">>");
			if (!method)
			{
				syntax_error(graph, left, "does not include >> operator");
				return NULL;
			}
		}

		response_t *result;
		result = syntax_return_of_operator(graph, method);
		if (!result)
		{
			return NULL;
		}

		return result;
	}

	else if (
		symbol_check_type(current, SYMBOL_DEFINE) ||
		symbol_check_type(current, SYMBOL_ASSIGN)
		)
	{
		symbol_t *right;
		right = syntax_extract_with(current, SYMBOL_RIGHT);
		
		response_t *response_right;
		response_right = syntax_expression(graph, right);
		if(!response_right)
		{
			return NULL;
		}

		return response_right;
	}

	else
	{
		response_t *response;
		response = syntax_expression(graph, current);
		if(!response)
		{
			return NULL;
		}
		return response;
	}
}

static response_t *
syntax_return(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		symbol_t *result;
		result = syntax_expression(graph, a);
		if(!result)
		{
			return NULL;
		}
	}

	return current;
}

static response_t *
syntax_continue(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		symbol_t *result;
		result = syntax_expression(graph, a);
		if(!result)
		{
			return NULL;
		}
	}

	return current;
}

static response_t *
syntax_break(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		symbol_t *result;
		result = syntax_expression(graph, a);
		if(!result)
		{
			return NULL;
		}
	}
	return current;
}

static response_t *
syntax_throw(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		symbol_t *result;
		result = syntax_expression(graph, a);
		if(!result)
		{
			return NULL;
		}
	}

	return current;
}

static response_t *
syntax_var(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if(!result)
			{
				return NULL;
			}
		}

		if (symbol_check_type(a, SYMBOL_TYPE))
		{
			symbol_t *b;
			for(b = a->begin; b != a->end; b = b->next)
			{
				symbol_t *result;
				result = syntax_find_type(graph, a, b, a, b);
				if (!result)
				{
					return NULL;
				}
			}
		}

		if (symbol_check_type(a, SYMBOL_VALUE))
		{
			symbol_t *b;
			for(b = a->begin; b != a->end; b = b->next)
			{
				symbol_t *result;
				result = syntax_expression(graph, b);
				if(!result)
				{
					return NULL;
				}
			}
		}
	}

	return current;
}

static response_t *
syntax_if(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if (!result)
			{
				return NULL;
			}
		}
		else if (symbol_check_type(a, SYMBOL_CONDITION))
		{
			symbol_t *result;
			result = syntax_block(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
		else if (symbol_check_type(a, SYMBOL_BLOCK))
		{
			symbol_t *result;
			result = syntax_block(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
		else if (symbol_check_type(a, SYMBOL_ELSE))
		{
			symbol_t *b;
			for (b = a->begin;(b != a->end); b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_IF))
				{
					symbol_t *result;
					result = syntax_if(graph, b);
					if(!result)
					{
						return NULL;
					}
				}
				else
				{
					symbol_t *result;
					result = syntax_block(graph, b);
					if(!result)
					{
						return NULL;
					}
				}
			}
		}
	}

	return current;
}

static response_t *
syntax_catch(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_BLOCK))
		{
			symbol_t *result;
			result = syntax_block(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
	}

	return current;
}

static response_t *
syntax_try(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_CATCH))
		{
			symbol_t *result;
			result = syntax_catch(graph, a);
			if(!result)
			{
				return NULL;
			}

		}
		else if (symbol_check_type(a, SYMBOL_BLOCK))
		{
			symbol_t *result;
			result = syntax_block(graph, a);
			if(!result)
			{
				return NULL;
			}

		}
	}

	return current;
}

static response_t *
syntax_for_init(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_VAR))
		{
			symbol_t *result;
			result = syntax_var(graph, a);
			if(!result)
			{
				return NULL;
			}

		}
		else if (symbol_check_type(a, SYMBOL_ASSIGN))
		{
			symbol_t *result;
			result = syntax_assign(graph, a);
			if(!result)
			{
				return NULL;
			}

		}
	}

	return current;
}

static response_t *
syntax_for_step(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_ASSIGN))
		{
			symbol_t *result;
			result = syntax_assign(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
	}

	return current;
}

static response_t *
syntax_for(graph_t *graph, symbol_t *root, symbol_t *subroot, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if (!result)
			{
				return 0;
			}
		}
		else if (symbol_check_type(a, SYMBOL_INITIALIZER))
		{
			symbol_t *b;
			for (b = a->begin;(b != a->end); b = b->next)
			{
				if (symbol_check_type(a, SYMBOL_FOR_INIT))
				{
					symbol_t *result;
					result = syntax_for_init(graph, b);
					if(!result)
					{
						return NULL;
					}
				}
				else if (symbol_check_type(a, SYMBOL_VAR))
				{
					symbol_t *result;
					result = syntax_var(graph, b);
					if(!result)
					{
						return NULL;
					}
				}
				else if (symbol_check_type(a, SYMBOL_ASSIGN))
				{
					symbol_t *result;
					result = syntax_assign(graph, b);
					if(!result)
					{
						return NULL;
					}
				}
			}
		}
		else if (symbol_check_type(a, SYMBOL_INCREMENTOR))
		{
			symbol_t *b;
			for (b = a->begin;(b != a->end); b = b->next)
			{
				if (symbol_check_type(a, SYMBOL_FOR_STEP))
				{
					symbol_t *result;
					result = syntax_for_step(graph, b);
					if(!result)
					{
						return NULL;
					}
				}
				else if (symbol_check_type(a, SYMBOL_ASSIGN))
				{
					symbol_t *result;
					result = syntax_assign(graph, b);
					if(!result)
					{
						return NULL;
					}
				}
			}
		}
		else if (symbol_check_type(a, SYMBOL_BLOCK))
		{
			symbol_t *result;
			result = syntax_block(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
	}

	return current;
}

static response_t *
syntax_forin(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if (!result)
			{
				return NULL;
			}
		}
		else if (symbol_check_type(a, SYMBOL_INITIALIZER))
		{
			symbol_t *b;
			for (b = a->begin;(b != a->end); b = b->next)
			{
				if (symbol_check_type(a, SYMBOL_VAR))
				{
					symbol_t *result;
					result = syntax_var(graph, b);
					if(!result)
					{
						return NULL;
					}
				}
			}
		}
		else if (symbol_check_type(a, SYMBOL_EXPRESSION))
		{
			symbol_t *result;
			result = syntax_expression(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
		else if (symbol_check_type(a, SYMBOL_BLOCK))
		{
			symbol_t *result;
			result = syntax_block(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
	}
	return current;
}

static response_t *
syntax_statement(graph_t *graph, symbol_t *current)
{
	symbol_t *result = NULL;

	if (symbol_check_type(current, SYMBOL_BLOCK))
	{
		result = syntax_block(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_IF))
	{
		result = syntax_if(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_TRY))
	{
		result = syntax_try(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_FOR))
	{
		result = syntax_for(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_FORIN))
	{
		result = syntax_forin(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_FUNCTION))
	{
		result = syntax_function(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_CONTINUE))
	{
		result = syntax_continue(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_BREAK))
	{
		result = syntax_break(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_RETURN))
	{
		result = syntax_return(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_THROW))
	{
		result = syntax_throw(graph, current);
	}
	else if (symbol_check_type(current, SYMBOL_VAR))
	{
		result = syntax_var(graph, current);
	}
	else
	{
		result = syntax_assign(graph, current);
	}

	return result;
}

static response_t *
syntax_block(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end);a = a->next)
	{
		symbol_t *result;
		result = syntax_statement(graph, a);
		if(!result)
		{
			return NULL;
		}
	}
	return current;
}

static response_t *
syntax_import(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_FIELD))
		{
			int32_t result;
			result = syntax_duplicated_in_name(graph, current, a, a);
			if(!result)
			{
				return NULL;
			}
			result = syntax_duplicated_in_name(graph, current->parent, current, a);
			if(!result)
			{
				return NULL;
			}
		}
	}
	return current;
}

static response_t *
syntax_generic(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if(!result)
			{
				return 0;
			}
		}
	}
	return current;
}

static response_t *
syntax_heritage(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if(!result)
			{
				return NULL;
			}
			symbol_t *root = current->parent;
			symbol_t *b;
			for(b = root->begin; b != root->end; b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_GENERIC))
				{
					result = syntax_duplicated_in_name(graph, root, b, b);
					if(!result)
					{
						return NULL;
					}
				}
			}
		}

		if (symbol_check_type(a, SYMBOL_TYPE))
		{
			symbol_t *b;
			for(b = a->begin; b != a->end; b = b->next)
			{
				symbol_t *result;
				result = syntax_find_type(graph, a, b, a, b);
				if (!result)
				{
					return NULL;
				}
			}
		}
	}

	return current;
}

static response_t *
syntax_method(graph_t *graph, symbol_t *current)
{
	symbol_t *root = current->parent;
	symbol_t *a;
	for (a = root->begin; a != root->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_GENERIC))
		{
			int32_t result;
			result = syntax_duplicated_in_name(graph, root, a, current);
			if(!result)
			{
				return NULL;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_HERITAGE))
		{
			int32_t result;
			result = syntax_duplicated_in_name(graph, root, a, current);
			if(!result)
			{
				return NULL;
			}
		}
	}

	for (a = current->begin; a != current->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			symbol_t *result;
			result = syntax_find_reference_primary(graph, current->parent, current, current->parent, syntax_only(a), NULL, NULL);
			if (result)
			{
				syntax_error(graph, a, "duplicated method");
				return NULL;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_BLOCK))
		{
			symbol_t *result;
			result = syntax_block(graph, a);
			if (!result)
			{
				return NULL;
			}
		}
	}

	return current;
}

static response_t *
syntax_enum(graph_t *graph, symbol_t *current)
{
	if (symbol_check_type(root, SYMBOL_CLASS))
	{
		symbol_t *root = current->parent;
		symbol_t *a;
		for(a = root->begin; a != root->end; a = a->next)
		{
			if (symbol_check_type(a, SYMBOL_GENERIC))
			{
				int32_t result;
				result = syntax_duplicated_in_name(graph, root, a, current);
				if(!result)
				{
					return NULL;
				}
			}
			
			if (symbol_check_type(a, SYMBOL_HERITAGE))
			{
				int32_t result;
				result = syntax_duplicated_in_name(graph, root, a, current);
				if(!result)
				{
					return NULL;
				}
			}
		}
	}

	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if(!result)
			{
				return NULL;
			}
		}
	}

	return current;
}

static response_t *
syntax_property(graph_t *graph, symbol_t *current)
{
	if (symbol_check_type(current->parent, SYMBOL_CLASS))
	{
		symbol_t *root = current->parent;
		symbol_t *a;
		for(a = root->begin; a != root->end; a = a->next)
		{
			if (symbol_check_type(a, SYMBOL_GENERIC))
			{
				int32_t result;
				result = syntax_duplicated_in_name(graph, root, a, current);
				if(!result)
				{
					return NULL;
				}
			}
			
			if (symbol_check_type(a, SYMBOL_HERITAGE))
			{
				int32_t result;
				result = syntax_duplicated_in_name(graph, root, a, current);
				if(!result)
				{
					return NULL;
				}
			}
		}
	}

	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if(!result)
			{
				return NULL;
			}
		}
	}

	return current;
}

static response_t *
syntax_class(graph_t *graph, symbol_t *current)
{
	
	symbol_t *a;
	for (a = current->begin;a != current->end;a = a->next)
	{
		// attribute
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if (!result)
			{
				return NULL;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_HERITAGE))
		{
			symbol_t *result;
			result = syntax_heritage(graph, a);
			if(!result)
			{
				return NULL;
			}

		}

		if (symbol_check_type(a, SYMBOL_GENERIC))
		{
			symbol_t *result;
			result = syntax_generic(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
		
		// subclass
		if (symbol_check_type(a, SYMBOL_CLASS))
		{
			symbol_t *result;
			result = syntax_class(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_METHOD))
		{
			symbol_t *result;
			result = syntax_method(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_ENUM))
		{
			symbol_t *result;
			result = syntax_enum(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
		
		if (symbol_check_type(a, SYMBOL_PROPERTY))
		{
			symbol_t *result;
			result = syntax_property(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
	}

	return current;
}

static response_t *
syntax_type(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if(!result)
			{
				return NULL;
			}
		}
	}
	return current;
}

static response_t *
syntax_field(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if(!result)
			{
				return 0;
			}
		}

		if (symbol_check_type(a, SYMBOL_TYPE))
		{
			symbol_t *b;
			for(b = a->begin; b != a->end; b = b->next)
			{
				symbol_t *result;
				result = syntax_find_type(graph, a, b, a, b);
				if (!result)
				{
					return NULL;
				}
			}
		}
	}
	return current;
}

static response_t *
syntax_parameter(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;(a != current->end); a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if(!result)
			{
				return NULL;
			}
		}

		if (symbol_check_type(a, SYMBOL_TYPE))
		{
			symbol_t *b;
			for(b = a->begin; b != a->end; b = b->next)
			{
				symbol_t *result;
				result = syntax_find_type_primary(graph, a, b, a, b, NULL);
				if (!result)
				{
					return NULL;
				}
			}
		}
	}

	return current;
}

static response_t *
syntax_function(graph_t *graph, symbol_t *current)
{
	symbol_t *a;
	for (a = current->begin;a != current->end;a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_NAME))
		{
			int32_t result;
			result = syntax_duplicated_in_set(graph, current->parent, current, a);
			if (!result)
			{
				return NULL;
			}
			symbol_t *b;
			for(b = current->begin; b != current->end; b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_FIELD))
				{
					result = syntax_duplicated_in_name(graph, current, b, b);
					if(!result)
					{
						return NULL;
					}
				}

				if (symbol_check_type(b, SYMBOL_GENERIC))
				{
					result = syntax_duplicated_in_name(graph, current, b, b);
					if(!result)
					{
						return NULL;
					}
				}
			}
		}

		if (symbol_check_type(a, SYMBOL_FIELD))
		{
			symbol_t *result;
			result = syntax_field(graph, a);
			if(!result)
			{
				return NULL;
			}
		}

		if (symbol_check_type(a, SYMBOL_GENERIC))
		{
			symbol_t *result;
			result = syntax_generic(graph, a);
			if(!result)
			{
				return NULL;
			}
		}

		if (symbol_check_type(a, SYMBOL_PARAMETER))
		{
			symbol_t *result;
			result = syntax_parameter(graph, a);
			if(!result)
			{
				return NULL;
			}
		}

		if (symbol_check_type(a, SYMBOL_BLOCK))
		{
			symbol_t *result;
			result = syntax_block(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
	}

	return current;
}



static response_t *
syntax_module(graph_t *graph, symbol_t *current)
{
	int32_t found = 0;
	symbol_t *a;
	for(a = current->begin; a != current->end; a = a->next)
	{
		/*
		if (symbol_check_type(a, SYMBOL_IMPORT))
		{
			symbol_t *result;
			result = syntax_import(graph, current, a, a);
			if(!result)
			{
				return NULL;
			}
		}
		else if (symbol_check_type(a, SYMBOL_CLASS))
		{
			symbol_t *result;
			result = syntax_class(graph, current, a, a);
			if(!result)
			{
				return NULL;
			}
		}
		else if (symbol_check_type(a, SYMBOL_ENUM))
		{
			symbol_t *result;
			result = syntax_enum(graph, current, a, a);
			if(!result)
			{
				return NULL;
			}
		}
		else if (symbol_check_type(a, SYMBOL_VAR))
		{
			symbol_t *result;
			result = syntax_var(graph, current, a, a);
			if(!result)
			{
				return NULL;
			}
		}
		else 
		*/
		if (symbol_check_type(a, SYMBOL_FUNCTION))
		{
			symbol_t *b;
			for (b = a->begin;b != a->end;b = b->next)
			{
				if (symbol_check_type(b, SYMBOL_NAME))
				{
					symbol_t *c;
					for (c = b->begin;c != b->end;c = c->next)
					{
						if (syntax_subset_compare_string(c, "init"))
						{
							found += 1;
						}
					}
				}

				if (symbol_check_type(b, SYMBOL_FIELD))
				{
					found = 0;
				}
			}

			if (found < 1)
			{
				found = 0;
				//continue;
			}

			symbol_t *result;
			result = syntax_function(graph, a);
			if(!result)
			{
				return NULL;
			}
		}
	}

	if (found < 1)
	{
		//syntax_error(graph, current, "missing init\n");
		//return NULL;
	}

	return current;
}

int32_t
syntax_run(graph_t *graph)
{
	symbol_t *symbol;
	symbol = (symbol_t *)graph->symbol;

	symbol_t *a;
	for(a = symbol->begin; a != symbol->end; a = a->next)
	{
		if (symbol_check_type(a, SYMBOL_MODULE))
		{
			symbol_t *result;
			result = syntax_module(graph, a);
			if(!result)
			{
				return 0;
			}
		}
	}

	return 1;
}


