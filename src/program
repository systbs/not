#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>

#include "types/types.h"
#include "utils/utils.h"
#include "utils/path.h"
#include "container/queue.h"
#include "token/position.h"
#include "token/token.h"
#include "program.h"
#include "error.h"
#include "scanner/scanner.h"
#include "ast/node.h"
#include "parser/syntax/syntax.h"
#include "parser/semantic/semantic.h"


void_t
Sy_programReport(program_t *program)
{
	fprintf(stderr,"Traceback:\n");

  sy_queue_entry_t *a;
  for(a = program->errors->begin; a != program->errors->end; a = a->next)
  {
		error_t *error = (error_t *)a->value;

		char base_path[MAX_URI];
		SyPath_GetCurrentDirectory(base_path, MAX_URI);

		if (error->position.offset == 0)
		{
			fprintf(stderr, 
				"%s\n", error->message
			);

			continue;
		}

		char relative_path[MAX_URI];
		SyPath_GetRelative(base_path, error->position.path, relative_path, sizeof(relative_path));
		
		fprintf(stderr, 
				"File \"%s\", Line %lld, Column %lld", 
				relative_path, 
				error->position.line, 
				error->position.column
		);

		sy_node_t *node1 = error->origin;
		while (node1 != NULL)
		{
			if (node1->kind == NODE_KIND_MODULE)
			{
				fprintf(stderr, 
					", <Module>"
				);
				break;
			}
			else
			if (node1->kind == NODE_KIND_CLASS)
			{
				sy_node_class_t *class1 = (sy_node_class_t *)node1->value;
				sy_node_t *key1 = class1->key;
				sy_node_basic_t *keSy_string1 = key1->value;

				fprintf(stderr, 
					", Class <%s>", keSy_string1->value
				);
				break;
			}
			else
			if (node1->kind == NODE_KIND_FUN)
			{
				sy_node_fun_t *fun1 = (sy_node_fun_t *)node1->value;
				sy_node_t *key1 = fun1->key;
				sy_node_basic_t *keSy_string1 = key1->value;

				fprintf(stderr, 
					", fun <%s>", keSy_string1->value
				);
			}
			node1 = node1->parent;
		}

		fprintf(stderr, 
				"\n%s\n", error->message
		);

		FILE *fp = fopen(error->position.path, "rb");

		if (fp == NULL)
		{
			fprintf(stderr, "%s-%u:could not open(%s)\n", 
				__FILE__, __LINE__, error->position.path);
			return;
		}
		
		uint64_t line = 0;

		char chunk[128];
		size_t len = sizeof(chunk);

		char *buf = malloc(len);
		if (buf == NULL)
		{
			fprintf(stderr, "%s-%u:Unable to allocted a block of %zu bytes\n", 
				__FILE__, __LINE__, sizeof(chunk));
			return;
		}

		buf[0] = '\0';
		while(fgets(chunk, sizeof(chunk), fp) != NULL) {
			size_t len_used = strlen(buf);
			size_t chunk_used = strlen(chunk);
	
			if(len - len_used < chunk_used) {
				len *= 2;
				if((buf = realloc(buf, len)) == NULL) {
					fprintf(stderr, "%s-%u:Unable to reallocate a block of %zu bytes\n", 
						__FILE__, __LINE__, sizeof(len));
					free(buf);
					return;
				}
			}

			strncpy(buf + len_used, chunk, len - len_used);
			len_used += chunk_used;

			if(buf[len_used - 1] == '\n') {
				line += 1;

				if ((line > error->position.line - 2) && (line < error->position.line + 2))
				{
					if (line == error->position.line)
					{
						fprintf(stderr, "  \033[31m%lld\033[m\t|", line);

						uint64_t j = 0;
						for (uint64_t i = 0;i < strlen(buf);i++)
						{
							j += 1;
							if (buf[i] == '\t')
							{
								j += 3;
							}
							
							if ((j >= error->position.column) && (j < error->position.column + error->position.length))
							{
								fprintf(stderr, "\033[1;31m%c\033[m", buf[i]);
							}
							else
							{
								fprintf(stderr, "%c", buf[i]);
							}
						}
					}
					else
					{
						fprintf(stderr, "  %lld\t|%s", line, buf);
					}
				}
				buf[0] = '\0';
			}
		}

		fclose(fp);

		free(buf);
  }
}

void_t
Sy_programPutPath(program_t *program, char *path)
{
	if (SyPath_IsRoot(path))
	{
		char base_path[MAX_URI];
		SyPath_Normalize(getenv ("QALAM_PATH"), base_path, MAX_URI);
		SyPath_Join(base_path, path + 2, program->base_file, MAX_URI);
	}
	else
	{
		char base_path[MAX_URI];
		SyPath_GetCurrentDirectory(base_path, MAX_URI);
		if(SyPath_IsRelative(path))
		{
			SyPath_Join(base_path, path, program->base_file, MAX_URI);
		}
		else 
		{
			SyPath_Normalize(path, program->base_file, MAX_URI);
		}
	}
}

void_t
Sy_programOutfile(program_t *program, char *path)
{
	memcpy(program->out_file, path, strlen(path));
}

program_t *
Sy_programCreate()
{
	program_t *program = (program_t *)malloc(sizeof(program_t));
	if (program == NULL)
	{
		fprintf(stderr, "%s-(%u):Unable to allocted a block of %zu bytes\n", 
			__FILE__, __LINE__, sizeof(program_t));
		return NULL;
	}
	memset(program, 0, sizeof(program_t));

	program->base_path = malloc(MAX_URI);
	if (program->base_path == NULL)
	{
		fprintf(stderr, "%s-(%u):Unable to allocted a block of %d bytes\n", 
			__FILE__, __LINE__, MAX_URI);
		return NULL;
	}
  	memset(program->base_path, 0, MAX_URI);

	program->base_file = malloc(MAX_URI);
	if (program->base_file == NULL)
	{
		fprintf(stderr, "%s-(%u):Unable to allocted a block of %d bytes\n", 
			__FILE__, __LINE__, MAX_URI);
		return NULL;
	}
  	memset(program->base_file, 0, MAX_URI);

	program->out_file = malloc(MAX_URI);
	if (program->out_file == NULL)
	{
		fprintf(stderr, "%s-(%u):Unable to allocted a block of %d bytes\n", 
			__FILE__, __LINE__, MAX_URI);
		return NULL;
	}
  	memset(program->out_file, 0, MAX_URI);

	program->errors = sy_queue_create();
	if(program->errors == NULL)
	{
		return NULL;
	}

	program->modules = sy_queue_create();
	if(program->modules == NULL)
	{
		return NULL;
	}

	program->repository = sy_queue_create();
	if(program->repository == NULL)
	{
		return NULL;
	}

	return program;
}