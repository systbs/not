using ValueError from "~/error";
using Print from "~/os";

export class Tensor<T extends float = float> {
    dims = [];
    values = [];
    export fun constructor(values) {
        var extract = fun(nested_list) {
            if (typeof nested_list != "tuple")
            {
                throw ValueError("Input must be a list");
            }
            
            var values = [];
            var dims = [];

            var extract_dimensions_and_values = fun (lst, reference current_dims, depth = 0) {
                if (typeof lst != "tuple")
                {
                    throw ValueError("All elements must be lists");
                }

                if (depth == current_dims.Count())
                {
                    current_dims.Append(lst.Count());
                }
                else if (current_dims[depth] != lst.Count())
                {
                    throw ValueError("Inconsistent dimensions at depth " + depth + ": expected " + current_dims[depth] + ", got " + lst.Count);
                }

                if (typeof lst[0] == "tuple")
                {
                    for (var sublist in lst)
                    {
                        extract_dimensions_and_values(sublist, current_dims, depth + 1);
                    }
                }
                else
                {
                    for (var item in lst)
                    {
                        if (!((item instanceof float) || (item instanceof int))) {
                            throw ValueError("All elements must be integers or floats");
                        }
                        values.Append(item);
                    }
                }
            };
            extract_dimensions_and_values(nested_list, dims);
            return {d:dims, v:values};
        };

        var {d, v} = extract(values);
        this.values = v;
        this.dims = d;
    }

    export fun GetIndex(*pos:int) {
        var index = 0;
        var stride = 1;
        for (var i = dims.Count() - 1; i >= 0; i -= 1) {
            index += pos[i] * stride;
            stride *= dims[i];
        }
        return index;
    }

    export fun GetPosition(index:int) {
        var pos = [];
        for (var i = dims.Count() - 1; i >= 0; i -= 1) {
            pos.Set(i, index % dims[i]);
            index \= dims[i];
        }
        return pos;
    }

    export fun GetDims() {
        return dims;
    }

    export fun [](start:int, stop:int = undefined, step:int = undefined) {
        if ((stop != undefined) && (step != undefined))
        {
            return values[start, stop, step];
        }
        else if (stop != undefined)
        {
            return values[start, stop];
        }
        else
        {
            return values[start];
        }
    }

    export fun Dot(t:Tensor<T>) {
        if (dims != t.GetDims())
        {
            throw ValueError("Dimensions of the tensors do not match");
        }

        var total_elements = values.Count();

        var result = 0;
        for (var i = 0; i < total_elements; i += 1) {
            result += values[i] * t[i];
        }
        
        return result;
    }
}