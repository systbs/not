using ValueError from "~/error";
using Print from "~/os";

export class Tensor<T extends float = float> {
    dims = [];
    values = [];
    export fun constructor(values) {
        var extract = fun(nested_list) {
            if (typeof nested_list != "tuple")
            {
                throw ValueError("Input must be a nd-array");
            }
            
            var values = [];
            var dims = [];

            var extract_dimensions_and_values = fun (lst, reference current_dims, depth = 0) {
                if (typeof lst != "tuple")
                {
                    throw ValueError("All elements must be nd-array");
                }

                if (depth == current_dims.Count())
                {
                    current_dims.Append(lst.Count());
                }
                else if (current_dims[depth] != lst.Count())
                {
                    throw ValueError("Inconsistent dimensions at depth " + depth + ": expected " + current_dims[depth] + ", got " + lst.Count);
                }

                if (typeof lst[0] == "tuple")
                {
                    for (var sublist in lst)
                    {
                        extract_dimensions_and_values(sublist, current_dims, depth + 1);
                    }
                }
                else
                {
                    for (var item in lst)
                    {
                        if (!((item instanceof float) || (item instanceof int))) {
                            throw ValueError("All elements must be integers or floats");
                        }
                        values.Append(item);
                    }
                }
            };
            extract_dimensions_and_values(nested_list, dims);
            return {dims, values};
        };

        var {dims, v:values} = extract(values);
        this.values = v;
        this.dims = dims;
    }

    export fun GetIndex(pos) {
        var index = 0;
        var stride = 1;
        for (var i = dims.Count() - 1; i >= 0; i -= 1) {
            index += pos[i] * stride;
            stride *= dims[i];
        }
        return index;
    }

    export fun GetPosition(index:int) {
        var pos = [];
        for (var i = dims.Count() - 1; i >= 0; i -= 1) {
            pos.Set(i, index % dims[i]);
            index \= dims[i];
        }
        return pos;
    }

    export fun GetDims() {
        return dims;
    }

    export fun GetValues() {
        return values;
    }

    export fun Reshape(dims) {
        if (typeof dims != "tuple")
        {
            throw ValueError("Input dims must be a tuple");
        }

        var total = 1;
        for (var dim in dims)
        {
            total *= dim;
        }

        if (total != values.Count())
        {
            throw ValueError("Total number of elements does not match the shape dimensions.");
        }

        this.dims = dims;

        return this;
    }

    export fun [](start:int, stop:int = undefined, step:int = undefined) {

        for (;start < 0;)
        {
            start += this.dims[0];
        }

        if (stop == undefined)
        {
            stop = start;
        }
        else
        {
            for (;stop < 0;)
            {
                stop += this.dims[0];
            }
        }
         
        if (step == undefined)
        {
            step = stop > start ? 1 : -1;
        }

        var new_dims = this.dims;
        if (step > 0)
        {
            var val = (stop - start - 1) \ step + 1;
            if (val == 0)
            {
                new_dims.Remove(0);
            }
            else
            {
                new_dims.Set(0, val);
            }
        }
        else
        {
            var val = (start - stop - 1) \ (step > 0 ? step : -step) + 1;
            if (val == 0)
            {
                new_dims.Remove(0);
            }
            else
            {
                new_dims.Set(0, val);
            }
        }

        var new_values = [];

        var extract_values = fun (position, current_dim){
            if (current_dim == this.dims.Count())
            {
                var index = this.GetIndex(position);
                new_values.Append(this.values[index]);
                return;
            }
            if (current_dim == 0){
                if (step > 0){
                    
                    for (var i = start;i <= stop;i += step)
                    {
                        extract_values(position.Append(i), current_dim + 1);
                    }
                }
                else
                {
                    for (var i = start;i >= stop;i += step)
                    {
                        extract_values(position.Append(i), current_dim + 1);
                    }
                }
            }
            else
            {
                for (var i = 0; i < this.dims[current_dim]; i += 1)
                {
                    extract_values(position.Append(i), current_dim + 1);
                }
            }
        };
        extract_values([], 0);

        Print(new_values);
        
        var t = Tensor<T>(new_values);
        t.Reshape(new_dims);

        return t;
    }
}